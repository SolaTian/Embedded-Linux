# 数据类型与存储

> 类型：一组数值及对该数值进行各种操作的集合。

同一种类型的数据，在不同的处理器平台下，存储方式可能不同；不同类型的数据，在同一种处理器平台下，存储方式和运算规则可能不一样。

## 大端模式和小端模式

字节是计算机最基本的存储单位，也是最小的寻址单元，计算机通常以字节为单位进行寻址。在一个32位的计算机系统中，通常4字节组成一个字。

一个数据在内存中有2种存储方式：
- 小端模式：高地址存储高字节数据，低地址存储低字节数据；
- 大端模式：高地址存储低字节数组，低地址存储高字节数据；

不同字节的数据在内存中的存储顺序被称为字节序。根据字节序的不同，将存储模式分为`大端模式`和`小端模式`。

![大小端](https://img-blog.csdn.net/20180822130000935?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzkxMTMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

[参考链接](https://blog.csdn.net/qq_36391130/article/details/81944217)

在网络传输中，网络字节序通常采用`大端字节序`，如果源端和目的端采用不同的大小端字节序，就需要转换字节序。


不同架构的处理器，存储模式一般也不相同，`ARM`、`X86`、`DSP`一般都采用小端模式，而`IBM`、`Sun`、`PowerPC`架构的处理器一般都采用大端模式。

    //测试平台是大端模式还是小端模式
    #include <stdio.h>

    int main(void)
    {
        int a = 0x11223344;
        char b;
        b = a;

        if(b == 0x44)
        {
            printf("小端模式\n");
        }
        else 
        {
            printf("大端模式\n");
        }
        return 0;
    }

将一个整型变量的值赋值给一个字符型变量，通常会发生截断，将低8位的一字节赋值给字符型变量。通过打印字符变量的值就可以知道当前处理器是`大端模式`还是`小端模式`。

    //通过联合体测试大小端
    #include <stdio.h>

    int main(void)
    {
        union u{
            int a;
            char b;
        }c;

        c.a = 0x11223344
        if(b.a == 0x44)
        {
            printf("小端模式\n");
        }
        else
        {
            printf("大端模式\n");
        }
        return 0;
    }

除了字节序，还有位序，一般情况下字节序和位序是一一对应的。小端模式下，低地址存储低字节数据，在一字节中，bit0地址用来存储这个字节的bit0位。大端模式下，bit0用来存储一字节的高比特位。


一般来讲，`小端模式`低地址存储低字节数据，比较符合人类的思维习惯；`大端模式`则更加适合计算机的处理习惯：不需要考虑地址和数据的对应关系，以字节为单位，把数据从左到右，按照从低到高的地址顺序直接读写即可。`大端模式`一般用在`网络字节序`、各种编解码中。

在处理网络数据时需要自己实现数据的大小端转换。如果编写的程序需要在不同架构的嵌入式平台上运行，还要考虑大小端模式的转化。

定义一个宏，将高、低地址上的数据互换，即可完成大小端存储模式的转换。

    #define swap_endian_u16(A)  \
        ((A & 0xFF00 >> 8) | (A & 0x00FF<< 8)))

在Linux内核源码的头文件目录`include/linux/byteorder`下，有3个头文件`big_endian.h`，`generic.h`，`little_endian.h`，有定义了不同类型的数据的大小端存储模式的相互转化，在驱动开发或内核编程的时候，可以直接使用这些封装好的`API`，不需要再自己定义。

## 有符号数和无符号数

在C语言中，如果定义的变量没有使用`signed`或者`unsigned`修饰，默认是`signed`有符号数。


对于一个字符型数据而言，有符号数能表示的范围为[-128,127]，无符号数能表示的范围为[0,255]，使用`printf()`打印数据时，可以使用`%d`和`%u`格式符分别格式化打印有符号数和无符号数。

一个存储在物理内存中的数据，可以被看做一个有符号数，也可以被看做无符号数，主要看怎么去解析它：使用`%d`打印，`printf()`就把它看做一个有符号数，使用`%u`，`printf()`就把它看做一个无符号数。


无符号数在存储时，所有的比特位都用来表示数的大小，没有原码，补码之说，直接转化成二进制即可。对于有符号数，则采用补码形式存储，一个有符号数有原码、反码、补码，反码即将原码的符号位保持不变，所有的数据位取反，补码等于反码+1。一个正数的补码等于其原码，一个负数的补码等于其反码+1。


如果所有有符号数据都使用原码编码，那么+0和-0的编码就会有两个00000000，10000000。采用补码，则+0和-0的编码都使用00000000，剩下的10000000，就可以表示-128。-128这个数只有补码，没有原码和反码。

采用补码，更重要的意义在于可以将减法运算转换成为加法运算，省去了`CPU`减法逻辑电路的实现，`CPU`只用实现全加器、求补电路即可同时支持加法运算和减法运算。有符号数在运算过程中，符号位也是参与运算的，和其他数据位的计算遵循相同的计算法则和进位处理。用补码表示的数据相加，当最高位有进位时，进位直接被丢弃。按照这种规则进行运算，上面的减法运算和加法运算得到的结果是一样的。

## 数据溢出

一般来说，无符号数溢出时会进行取模运算，继续周期轮回，如一个`unsigned char`当其循环到255最大值时继续加1，这个数就变成了0，重新循环。当有符号数溢出时，发生的结果是不确定的，不同的编译器环境下编译运行，结果可能不一样。

发生数据溢出的判断：
- 两个有符号数相加，如果两个正整数相加的和小于0，说明运算过程中发生了数据溢出；
- 两个无符号数相机，如果两个数的和小于其中任何一个加数，说明运算过程中发生了数据溢出。

## 数据类型转换

数据类型转换分成两种：一种是隐式类型转换，一种是强式类型转换。如果程序员没有对类型进行强转，则编译器在编译程序时就会自动进行隐式类型转换。

一个C程序中发生隐式类型自动转换，主要有以下几种情况：
- 算数运算、逻辑运算、赋值表达式中运算符两侧数据类型不相同时；
- 函数调用过程中，传递的实参和形参类型不匹配时；
- 函数返回值类型与函数声明的类型不匹配时；

转换精度一般按照从低精度向高精度，从有符号数向无符号数方向转换

    char->short->int->unsigned->long->double->long double
    char->short->int->long->long long->float->double

一个有符号数和无符号数比较大小时，编译器会将它们两个都转换为无符号数。


强制类型转换的时候需要注意一个问题，数据的值在转换的过程中可能会发生改变：在将一个`char`型数据转换成`int`类型数据时，值保持不变，但是存储格式发生了变化，将`char`型数据保存在32位中的低8位地址空间，其余的高24位使用符号位填充。在将一个`int`类型数据转换成`char`型数据时，会发生截断，将`int`数据的低8位赋值给了`char`型数据，其余`bit`位丢弃。

一个有符号数转换成为无符号数时，数据的存储格式不会发生变化，但是值会发生变化，因为此时有符号数的符号位变成了无符号数的数据位。

# 数据对齐

## 数据对齐的意义

如果一个`short`类型的整型变量被分配到了奇数地址上，一个`int`型的整型变量被分配到了非4字节对齐的地址，则这些变量的地址就未对齐。

为什么变量在内存中非要地址对齐？

主要是由`CPU`硬件决定的。不同处理器平台对存储空间的管理不同。有些`CPU`在设计时简化了地址访问，只支持边界对齐的地址访问，因此编译器根据处理器平台的不同，选择合适的地址对齐方式。以确保`CPU`能够正常访问这些存储空间。定义了一个`int`型变量，如果将它分配到内存中2字节对齐的地址空间上，那么它的存储地址就没有对齐，`CPU`在读写这个数据时，本来一个指令周期就可以完成，现在可能需要用2个指令周期。

## 结构体对齐

定义一个结构体变量时，编译器会按照下面的原则在内存中给这个变量分配合适的存储空间：
- 结构体内各个成员按照各自数据类型对齐模数对齐；
- 结构体整体对齐方式：按照最大成员的`size`或者其`size`的整数倍对齐；

结构体之所以要对齐，根本原因是为了加快`CPU`访问内存的速度，在具体的实现上，一般都采用每种数据类型默认对齐模数`sizeof(type)`对齐。`GCC`默认的最大对齐模数为4。超过4字节时依然会按照4字节对齐，这是`GCC`和`arm-linux-gcc`，`Visual Studio`等编译器不一样的地方。

结构体中内嵌结构体，那么结构体作为其中一个成员也要按照自身类型的对齐模数对齐。结构体自身的对齐模数是该结构体中最大成员的`size`，或者`size`的整数倍。

    //person.c
    #include <stdio.h>

    struct student{
        char sex;
        double num;
    };

    struct person{
        char age;
        struct student stu;
    };

    int main(void)
    {
        struct person her;
        printf("&her.age = %p\n", &her.age);
        printf("&her.stu.sex = %p\n", &her.stu.sex);
        printf("&her.stu.num = %p\n", &her.stu.num);
        printf("person size: %d\n", sizeof(struct person));
        printf("stu size: %d\n", sizeof(her.stu));
        return 0;
    }

在`GCC`编译器环境下，`student`的对齐模数为4字节，因此`student`的成员大小为12字节，整个`person`的结构体的大小为最大对齐模数的整数倍：4*4 = 16字节

    &her.age = 0xbf8acadc
    &her.stu.sex = 0xbf8acae0
    &her.stu.num = 0xbf8acae4
    person size: 16
    stu size: 12

在`arm-linux-gcc`编译环境下，`student`的成员`num`的`sizeof(num)`是8字节，因此结构体`student`的对齐模数为8，结构体`person`要按照8字节字节对齐分配空间，而且结构体大小腰围最大对齐模数的整数倍。

    &her.age = 0xbf8acaf0
    &her.stu.sex = 0xbf8acaf8
    &her.stu.num = 0xbf8acb00
    person size: 24
    stu size: 16

## 联合体对齐

联合体的对齐规则：
- 联合体的整体大小：最大成员对齐模数或对齐模数的整数倍；
- 联合体的对齐原则：按照最大成员的对齐模数对齐；

    //union.c
    #include <stdio.h>

    union u{
        char sex;
        double num;
        int age;
        char a[11];
    };

    int main(void)
    {
        union u stu;
        printf("&stu.sex = %p\n", &stu.sex);
        printf("&stu.num = %p\n", &stu.num);
        printf("&stu.age = %p\n", &stu.age);
        printf("&stu.a = %p\n", &stu.a);
        printf("union size: %d\n", sizeof(union u));
        return 0;
    }

在`GCC`编译环境下，联合体成员的最大对齐模数为4，整个联合体的大小是4的公倍数：4*3=12字节

    &stu.sex = 0xbfb5bce0
    &stu.num = 0xbfb5bce0
    &stu.age = 0xbfb5bce0
    &stu.a = 0xbfb5bce0
    union size: 12

在`arm-linux-gcc`编译环境下，联合体成员的最大对齐模数是8，所以整个联合体的大小是8的公倍数：8*2=16字节。

    &stu.sex = 0x7e8d9cf8
    &stu.num = 0x7e8d9cf8
    &stu.age = 0x7e8d9cf8
    &stu.a = 0x7e8d9cf8
    union size: 12

无论是基本数据类型还是复合数据类型，编译器在为各个变量分配地址空间时，会按照大家各自的默认对齐模数进行地址对齐。除此之外，还可以通过`#pragma`或者`GNU C`编译器的`aligned/packed`属性声明来显示指定对齐方式。

# 数据的可移植性

`sizeof(int)`在`GCC`编译环境下，运行结果可能是4字节，如果使用64位编译器在64位处理器上编译运行，运行结果则可能是8字节。

当程序在不同的编译环境下运行时，`int`型数据的大小就可能发生变化，也就是说`int`类型不具备可移植性。

使用C语言提供的`typedef`关键字来定义一些固定大小的数据类型

    //data_type.h
    typedef unsigned char   UINT8;
    typedef unsigned short  UINT16;
    typedef unsigned int    UINT32;
    typedef unsigned long long UINT64;
    typedef signed char     INT8;
    typedef short           INT16;
    typedef int             INT32;
    typedef long long       INT64;

将这些关键字定义在`data_type.h`头文件中，实际编程时，如果需要使用一个32位固定大小的无符号数时，先`#include "data_type.h"`然后直接使用`UINT32`来定义变量。在另外一个平台上`unsigned int`变成了2字节，可以直接修改`data_type.h`，将`UINT32`使用`unsigned long`重新定义一遍。


通过修改`data_type.h`对`UINT32`类型重新定义之后，`UINT32`的长度还是32位，程序中所有使用`UINT32`的地方都不用修改，`UINT32`这个数据类型因此就具备了可移植性，可以在多个平台上运行。


现在的操作系统一般都会支持多种`CPU`架构，多种处理器平台。操作系统为了实现跨平台运行，一般都会考虑数据的可移植性，如大小端存储模式、数据对齐、字长等。在编程时，可以把程序中与系统、平台相关的部分隔离封装在一个单独的头文件或者配置文件中，整个程序中的可移植部分和不可移植部分分开。便于后续的管理、升级和维护。

# Linux内核中的size_t

Linux内核中的数据类型总体分为3类：
- C语言的基本数据类型：`int`、`char`、`short`
- 长度确定的数据类型：`long`
- 特定内核对象的数据类型：`pid_t`，`size_t`

数据类型`size_t`一般使用`#define`宏定义，后面使用一个`_t`的后缀表示Linux内核中在某些地方特定使用的数据类型。

    #define unsigned int size_t

`size_t`数据类型一般用在表示长度、大小等无关正负的场合，如数组索引、数据复制长度、大小等。

在Linux内核源码中

    int valid_phys_addr_range(phys_addr_t addr, size_t size);
    char *strncpy(char *, const char *, size_t);

在C语言标准库中

    void* _cdecl _MINGW_NOTHROW   malloc(size_t);

使用`size_t`不仅仅是考虑到数据类型的可移植性，`size_t`的另一个优点是其大小并非是固定的，而是用来**表征针对某个平台的最大长度**。当使用无符号型的`size_t`用来表示一个地址或者数据复制的长度时，所以不用担心它表示的数值范围不够用。

# 为什么很多人喜欢用typedef

`typedef`用来给某个类型起别名。

## typedef的基本用法

在C语言中，使用`struct`关键字来定义一个结构体类型。

    struct student
    {
        char name[20];
        int age;
        float score;
    };
    struct student stu = {"wit", 20, 99};

在C语言中，必须加上`struct`关键字，编译器才会理解是一个结构体变量，在C++中，可以不用加`struct`关键字，可以直接使用。

    struct student
    {
        char name[20];
        int age;
        float score;
    };

    int main(void)
    {
        student stu = {"wit", 20, 99};
        return 0;
    }

使用`typdef`关键字，可以给`student`声明一个别名`student_t`和一个结构体指针类型`student_ptr`，然后使用`student_t`类型去定义一个结构体变量，不用再写`struct`。

    #include <stdio.h>

    typedef struct student 
    {
        char name[20];
        int age;
        float score;
    }student_t, *student_ptr;

    int main(void)
    {
        student_t stu = {"wit", 20, 99};
        student_t *p1 = &stu;
        student_ptr p2 = &stu;
        printf("name: %s\n", p1->name);
        printf("name: %s\n", p2->name);
        return 0;
    }

`typedef`除了可以与结构体使用，还可以与数组结合使用

    typedef int array_t[10];
    array_t array;
    int main(void)
    {
        array[9] = 100;
        printf("array[9] = %d\n", array[9]);
        return 0;
    }

声明了一个数组类型`array_t`，然后用这个`array_t`定义一个数组`array`，这个`array`就是相当于`int array[10];`

`typedef`还可以与指针结合使用：

    typedef char * PCHAR;

    int main(void)
    {
        PCHAR str = "hello world";
        printf("str:%s\n", str);
        return 0;
    }

`typedef`与函数指针结合使用，定义一个函数指针

    int (* func)(int a, int b);

    typedef int (* func)(int a, int b);
    func_t fp;

    int sum(int a, int b)
    {
        return a+b;
    }

    int main(void)
    {
        func_t fp = sum;
        printf("%d\n", fp(1, 2));
        return 0;
    }

也可以这样声明

    typedef int (func_t)(int a, int b);
    func_t *fp = sum;

`typedef`还可以与枚举结合使用，使用方法和结构体类似。

## typedef的优势

1. 可以让代码更加清晰简洁
2. 增加代码的可移植性，就是之前说的自定义数据类型，在不同的平台上只需要修改头文件即可。
3. 比宏定义更加好用，可以使用该类型同时定义多个同类型对象，而宏不可以

        typedef char* PCHAR

        PCHAR pch1, pch2;
4. 让复杂的指针声明变得更加简洁

        typedef int *(*func_ptr_t)(int p, int len, char name[]);
        func_ptr_t array[10];


## 使用typedef的注意点

1. `typedef`和`const`一起修饰一个指针类型时

        //指针常量和常量指针
        char b = 10;
        char c = 20;
        int main(void)
        {
            char const *p1 = &b;        //常量指针，*p1不可变，p1可变
            char *const p2 = &b;        //指针常量，*p2可变，p2不可变
            p1 = &c;                    //编译正常
            *p1 = 20;                   //错误
            p2 = &c;                    //错误
            *p2 = 20;                   //编译正常
            return 0;
        }

        typedef char* PCHAR2;
        #define PCHAR1 char*

        char b = 10;
        char c = 20;
        int main(void)
        {
            const PCHAR1 p1 = &b;           //等价于const char* p1是一个常量指针
            const PCHAR2 p2 = &b;           //PACHR2是一个类型，可以与const互换位置，等价于char* const p2是一个指针常量
            p1 = &c;            //编译正常
            *p1 = 20;           //错误
            p2 = &c;            //错误
            *p2 = 20;           //编译正常
        } 
2. `typedef`是一个存储类关键字，和常见的存储类关键字`auto`，`register`，`static`，`extern`一样，在修饰一个变量的时候，不能同时使用一个以上的存储类关键字，否则会报错。

## typedef的作用域

宏是全局的，而`typedef`作为一个存储类关键字，是有作用域的。使用`typedef`声明的类型和普通变量一样，遵循作用域规则。

## 避免typedef被滥用

一般来说，遇到以下情形时，使用`typedef`可能更加合适，否则会适得其反
1. 创建一个新的数据类型
2. 跨平台的指定长度的类型，如`U32/U16/U8`
3. 与操作系统，`BSP`，网络字宽相关的数据类型，如`size_t`、`pid_t`等
4. 不透明的数据类型，需要隐藏结构体细节，只能通过函数接口访问的数据类型。

# 枚举类型

使用`enum`定义的枚举常量值列表中，默认从0开始，然后依次递增，也可以显式指定

    enum week
    {
        SUN = 1,
        MON,            //2
        TUE,            //3
        WED,            //4
        THU = 7,
        FRI,            //8
        SAT,            //9
    };


## 使用枚举的三种方法

    //定义枚举类型的同时，直接定义枚举变量
    enum week
    {
        SUN = 1,
        MON,            //2
        TUE,            //3
        WED,            //4
        THU = 7,
        FRI,            //8
        SAT            //9
    }today, tomorrow;

    //省去枚举类型名
    enum 
    {
        SUN = 1,
        MON,            //2
        TUE,            //3
        WED,            //4
        THU = 7,
        FRI,            //8
        SAT            //9
    }today, tomorrow;

    //先定义枚举类型，再定义枚举变量
    enum week
    {
        SUN = 1,
        MON,            //2
        TUE,            //3
        WED,            //4
        THU = 7,
        FRI,            //8
        SAT            //9
    };
    enum week today, tomorrow;

## 枚举的本质

枚举是一种类型，属于整型类型。枚举有点类似`typedef`，为数值添加一个别名，让程序更加直观，可读性更高。枚举类型的本质就是有命名的整数，是整型类型的一种。

枚举和预处理指令`#define`作用差不多，但是宏在预处理阶段就被替换掉了，但是枚举类型是在编译阶段被替换成整型。相比于宏需要一个一个定义，枚举可以自动赋值。


## Linux内核的枚举类型

在Linux内核中使用`enum`定义的枚举名是没有枚举名的。当我们不需要使用枚举类型去定义一个变量时，枚举不需要一个名字，这些无名的枚举类型就相当于宏定义。而最后一个元素`NR`或者`MAX`，一般用来记载枚举列表中元素的个数，或者作为循环判断的边界值。

    enum 
    {
        MM_FILEPAGES,
        MM_ANONPAGES,
        MM_SWAPENTS,
        NR_MM_COUNTERS
    }

    enum pid_type
    {
        PIDTYPE_PID,
        PIDTYPE_PGID,
        PIDTYPE_SID,
        PIDTYPE_MAX
    }

## 使用枚举的注意点

在同一个作用域内不能出现重名的枚举常量名。

    enum week1
    {
        SUN,MON,TUE,WED,THU,FIR,SAT
    }

    enum week2
    {
        SAT,UNKNOWN
    }

# 常量和变量

## 变量的本质

汇编语言中是没有数据类型的概念的，当为一个数据对象分配存储空间时，主要考虑的就是`存储地址`，`存储大小`和`存储内容`。它们和高级语言中的`变量名`，`变量类型`和`变量值`是一一对应的。

> 变量名的本质：一段内存空间的别名。

编译器在编译程序的时候，会把变量名看做一个符号，符号值即是变量的地址，各种不同的符号保存在符号表中。可以通过变量名对和它绑定的内存单元进行读写，而不是直接使用内存地址。通过变量名访问内存，即方便了程序的编写，也大大增强了程序的可读性。


在C语言中，一块可以存储数据的内存区域，叫做`对象`。操作这片内存的表达式，即引用`对象`的表达式，称为左值。一般放在赋值语句的左边。

数组名、函数、枚举常量、函数调用等都不能作为左值。

    int a[10];
    a = {1,2,3,4,5,6,7,8,9,0};          //编译错误

一个变量作为左值时，通常表示对象的地址，对变量名的引用就是对该地址区域进行各种操作。一个变量名作为右值时，通常表示对象的内容，此时对变量名的引用就相当于取该地址区域上的内容。

    a = 1;
    b = a;

### 存储类关键字

> 存储类关键字：决定变量的存储位置、作用域周期或者生命周期。

- `static`：修饰一个局部变量时，可以改变变量的存储方式，将变量的存储从栈中转移到数据段中，但是不能改变变量的作用域。修饰一个全局变量时，将全局变量的作用域限定在本文件中。
- `extern`：全局变量一般存储在数据段中，使用`extern`可以将一个全局变量的作用域扩展到另一个文件中。
- `register`：告诉编译器，这个变量会被频繁的使用，如果有可能，则将这个变量存储在`CPU`的寄存器中，提高读写效率。但是具体视编译器而定。
- `auto`：一个函数内定义的变量，如果没有使用其他存储类修饰符修饰，默认就是`auto`类型，即自动变量。自动变量存储于当前函数的栈帧中。函数中的每一个局部变量只有在函数运行时，才会给其分配存储空间，在函数执行结束时退出自动释放，其声明周期只存在于函数运行期间。在一个函数中，如果一个自动变量没有初始化，则它的值是随机的，这时因为在函数运行期间分配的存储单元地址是随机的，存储单元的数据也是随机的。


## 常量存储

常量字符串，`printf()`中的打印格式的字符串，使用`const`修饰的变量，编译时被放在`.rodata`只读数据段中。

## 常量折叠

当程序中存在常量表达式时，编译器会在编译时把常量表达式优化成一个固定的常量值，节省存储空间，称为常量折叠。

    int val = 2*3 + 5*4;        //编译器直接优化成26

# 变量到指针

|内存分类|说明|
|-|-|
|静态内存|程序被加载到内存中，代码段和数据段<li>静态内存中各个变量的地址在编译期间就已经确定了，在程序运行期间不会改变；<li>静态内存在程序运行期间不再发生变化，可以通过变量名直接访问，变量的地址在编译期间就已经确定了。|
|动态内存|堆栈内存<li>动态内存中变量的地址在程序运行期间是不固定的，如函数的局部变量；<li>对于栈，虽然每次函数分配的栈帧空间不同，但是每个局部变量在函数栈帧中相对于栈帧指针`FP`的相对偏移不变，每一次函数运行都可以正常访问；<li>对于`malloc()`申请的堆内存，不仅是动态变化的，而且还是匿名内存，无法通过变量名或者栈指针来访问，只能使用指针来间接访问。|


## 指针的本质

指针变量也是一个变量，区别在于普通变量存放的是一个数，而指针变量存放的是一个地址。

`int`变量的类型是`int`，指针变量的类型是指针。指针的本质就是一种数据类型。指针类型和算数类型都是C语言的基本类型，C语言还有其他类型，如结构类型，数组类型，联合类型，函数类型，`void`类型等。

指针分为：对象指针和函数指针。

指针也是有类型的，指针的类型和其指向的数据类型有关：指向`int`型变量，则指针类型为`int *`，指向`char`型变量，则指针类型为`char *`，指向一个函数，则这个指针的类型为`void (*f)(int, int)`，无论这个指针是什么类型，存放的都是一个地址，只不过这个地址存放不同类型的数据而已。

一个指针变量无论是什么类型，它的大小都是固定的，只和系统有关，和类型无关。如`sizeof(int *)`，`sizeof(char *)`，`sizeof(long *)`大小均相同。

既然指针变量所占的内存空间大小不会变，为什么还要指定一个类型？

为指针指定类型主要是为了编译器的类型检查，编译器在编译过程中，会根据指针指向的数据类型对程序进行语义检查，看程序有没有错误。另一个重要的原因是不同类型的指针运算规则不一样，更适合通过指针去访问不同类型的变量。


|指针变量和普通变量|说明|
|-|-|
|普通变量|<li>存放数；<li>采用直接寻址，即可以当左值又可以当右值|
|指针变量|<li>存放地址；<li>采用间接寻址，当指针变量通过间接寻址时，其又等价为一个普通变量|

    int a = 10;
    int b = 20;
    int *p = &a;
    a = b;
    b = a;
    *p = b;
    b = *p;

## 复杂的指针声明

|指针类型分类||
|-|-|
|函数指针|指向一个函数，指针变量存储的是函数的入口地址。如`void (*fp)(int, int)`|
|对象指针|指针指向不同的数据，如`char *`，`int *`，`long *`，`struct xx *`|
|`void *`指针|一般作为通用指针，作为函数的参数。既不属于对象指针，也不属于函数指针。|

与指针相关的运算：
- 指针声明：`int *`
- 取址运算符：`&`
- 间接访问运算符：`*`
- 自增自减运算符：`++`，`--`
- 成员选择运算符：`.`，`->`
- 其他运算符：`[]`，`()`

这些运算符按照优先级从高到低的顺序依次为：`[]`，`()`，`.`，`->`，`++`，`--`，`*`，`&`。

    *p++;                        //p先间接访问，然后p再自增
    &p++;                        //指针变量地址自增运算
    &stu.a;                      //结构体成员变量a的地址
    int *a[10];                  //定义一个指针数组，数组元素类型为int *
    int (*a)[10];                //定义一个数组指针，指向数组类型int a[10]
    int *f(int);                 //定义一个指针函数，函数的返回值为int *
    int (*f)(int);               //定义一个函数指针，指向函数类型为int f(int)
    int *(*f)[10];               //定义一个数组指针，指向数组类型int *a[10]
    int *(*(*f)(int))[10];       //

复杂指针声明中，可以采用左右法则来进行判断。

> 首先从最里面的圆括号（未定义标识符）看起，先往右看，再往左看，每当遇到圆括号时，就应该调转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程，直到声明解析完毕。

分析上面最后一个声明：
1. 最里面的圆括号：`f`是一个指针，那么整个表达式就是一个指针；
2. 往右看，是一个参数列表`(int)`，指针类型是一个函数指针；
3. 再往左看，是一个符号`*`，说明该指针指向的函数的返回值是一个指针；
4. 括号解析完毕，跳出圆括号；
5. 再往右看，是一个数组`[10]`
6. 再往左看，是一个`int *`
7. 最终得出，定义了一个函数指针，指针指向一个函数，这个函数的形参为`int`，返回值是一个指向指针数组的指针，指针数组的元素类型是`int *`

分析下面几个指针声明

    int (*f(int, int))[10];
    int (*(*f)[10])(int *p);
    int (*(*f)(int, int))(int);
    int (*f)(int *p, int, int (*fp)(int *, int));


## 指针类型和运算

指针运算：`p++`实际相当于`p+1*sizeof(type)`。`p++`总是指向下一个元素的地址。

两个指针之间可以相减，但是前提是指针类型需要一致，而且只能相减，不能相加。相减的结果表示两个指针在内存中的距离。两个指针相减的结果以数据类型的长度`sizeof(type)`为单位，并非以字节为单位。

指针还支持关系运算，但是指针的类型必须相同：
- `p == q`：`p`和`q`指向同一个数据
- `p<q`：`p`指向的数据在`q`指向数据的前面
- `p>q`：`p`指向的数据在`q`指向数据的后面

# 指针和数组的关系

指针和数组的关系：
- 数组名作为函数参数时相当于一个指针地址；
- 数组和指针一样，都可以通过间接运算符`*`访问
- 数组和指针一样，都可以通过下标运算符`[]`访问

|指针|数组|
|-|-|
|间接访问|直接访问|
|用于动态内存、链表|用于存储一组固定长度的相同元素|
|通常指向匿名数据|数组名作为数组首元素地址|

## 下标运算符[]

下标运算符`[]`是数组用来访问数组元素的运算符，间接访问运算符`*`是指针用来访问内存的运算符。这两个运算符可以混用。

之所以可以混用，是因为C语言对下标运算符的访问，是通过转化成指针来实现的。

    E1[E2] --> *(E1+E2)

数组名代表的是数组首元素的地址，相当于一个指针常量。不管是通过下标访问，还是通过指针访问，最后都会转化成为`*(E1+E2)`的形式。

    #include <stdio.h>

    int a[5] = {0,1,2,3,4};

    int main(void)
    {
        int i = 10;
        int *p = a;
        printf("%d\n", p[0]);           //*(p+0)
        printf("%d\n", 0[p]);           //*(0+p)
        printf("%d\n", (p+2)[-2]);      //*(p+2-2)
        printf("%d\n", 0[p+2]);         //*(0+p+2)
        printf("%d\n", (-1)[p+2]);       //*(-1+p+2)
        printf("%d\n", -1[p+2]);         //-*(1+p+2)
        printf("%d\n", 1[p+2]);            //*(1+p+2)
        p = &i;
        printf("%d\n", 1[&i-1]);           //*(1+&i-1)
        return 0;
    }

## 数组名的本质

数组名作为函数参数传递时，传递的其实就是数组的首元素地址。数组的长度要通过另一个参数`len`传递，直接通过数组名本身是无法进行传递的。下面的声明是等价的。

    void array_print(int array[5], int len);
    void array_print(int array[], int len);

数组名也是有类型的，定义一个字符数组`char a[5]`，数组名`a`的类型就是`char [5]`，`&a`的类型就是`char (*)[5]`。定义一个常量指针`char *const p`，则`p`的类型就是`char *const`。数组名和常量指针不是一回事。

    #include <stdio.h>

    char a[5] = {0,1,2,3,4};
    char *const p = a;

    int main(void)
    {
        printf("sizeof(a):%d\n", sizeof(a));
        printf("sizeof(p):%d\n", sizeof(p));
        printf("a   :%p\n", a);
        printf("a+1 :%p\n", a+1);
        printf("&a+1:%p\n", &a+1);          //&a表示数组a的地址，&a+1表示数组a后面一个元素的地址，即a[5]+1
        return 0;
    }
程序运行结果

    sizeof(a):5
    sizeof(p):4
    a       :0x804a01c
    a+1     :0x804a01d
    &a+1    :0x804a021


数组也存在隐式转换，不同场合代表不同的意义。当我们使用数组名声明一个数组，或者使用数组名和`sizeof`、取址运算符`&`相结合使用时，数组名表示的数组类型。在其他情况下，数组名都是一个右值，表示数组首元素的地址，可以与间接运算符`*`构成一个左值表达式。

    #include <stdio.h>

    int main(void)
    {
        int a[20] = {0};
        *(&a[0]) = 1;
        printf("%d\n", a[0]);
        return 0;
    }

程序运行结果：

    1

## 指针数组和数组指针

指针数组的本质是一个数组，数组里面每一个元素存放的是地址；数组指针的本质是一个指针，这个指针指向的数据类型是一个数组。

    #include <stdio.h>

    char *season[4] = {"Spring", "Summer", "Autumn", "Winter"};
    int a[2][4] = {0, 1, 2, 3, 4, 5, 6, 7};

    void pointer_array_print()
    {
        int i;
        for(i=0; i<4; i++)
        {
            printf("hello %s\n", season[i]);
        }
    }

    void array_pointer_print(void)
    {
        int i;
        int (*pa)[4];
        int *p;
        pa = a;         //&a[0]
        p = a[0];       //&a[0][0]
        printf("pa:%p, pa+1:%p", pa, pa+1);
        printf("p:%p, p+1:%p", p, p+1);

        pa = &a[1];     //&(&a[1][0])
        for(i=0; i<4; i++)
        {
            printf("%d", pa[0][1]);
        }
        puts("");
        p = a[1];
        for(i=0; i<4; i++)
        {
            printf("%d",p[i]);
        }
        put("");
    }

    int main(void)
    {
        pointer_array_print();
        array_pointer_print();
        return 0;
    }

`a`是一个二维数组，有两种方法访问二维数组：
- 指向数组元素的指针`p`，类型为`int *`；
- 指向数组的元素`pa`，类型为`int (*)[4]`数组指针，指向的数组类型为`int [4]`；

二维数组的数组名作为右值时表示的是数组首元素的地址，二维数组可以看做特殊的一维数组，数组里的每个数组元素还是一个数组，`pa = a`相当于将一维数组的地址赋值给了`pa`，`pa[0]`相当于一维数组的数组名，再通过`pa[0][i]`即可遍历这个一维数组。


数组指针的一个应用就是作为函数参数，用来传递一个二维数组的地址

    #include <stdio.h>

    int array1[3][5] = {
        1,2,3,4,5,
        6,7,8,9,0,
        2,2,2,2,2
    };

    void array_print(int (*a)[5], int len)
    {
        int i, j;
        for(i=0; i<len; i++)
        {
            for(j=0; j<5; j++)
                printf("%d ", a[i][j]);
            puts("");
        }
    }

    int main(void)
    {
        array_print(array1, 3);
        puts("");
        return 0;
    }

程序输出结果为

    1 2 3 4 5
    6 7 8 9 0
    2 2 2 2 2

一维数组作为函数的参数时，数组名就转换为数组首元素的地址。二维数组作为函数的参数时，数组名同样转换为数组首元素的地址`&a[0]`，只不过这个首元素是一个`int [5]`类型的数组，因此，`array_print(int (*a)[5], int len)`中的5不能省略。


|区别|数组指针|指针数组|
|-|-|-|
|传递一维数组的地址|传递了数组`int arr[4]`的首地址，<br>定义和声明：`void func(int *arr, int len)`<br>调用：`func(arr, sizeof(arr)/sizeof(int));`|指针数组自动退化成指向数组首元素的指针，<br>定义和声明：`void func(int *arr[] ,int size)`<br>调用：`func(arr, sizeof(arr)/sizeof(int))`|
|传递二维数组的地址|传递了数组`int arr[2][3]`的首地址，<br>定义和声明：`void func(int (*arr)[3], int rows, int cols)`<br>调用：`func(arr, 2, 3);`|传递指向数组首行的指针<br>定义和声明：`void func(int (*arr[])[3], int rows)`<br>调用：`func(arr, 2);`|


# 指针和结构体

结构体是一个标量，当结构体作为函数的参数或者返回值时，传递的是整个结构体所有成员的值，这一点和数组是不同的，数组名作为参数传递时传递的仅仅是一个地址。大块的数据通过函数参数或者返回值来回复制，会影响程序的效率，因此在实际的编程中，当需要结构体传参时，一般都使用结构体指针来实现。

# 二级指针

> 指针变量主要用来存储一块内存的地址，然后通过间接访问运算符`*`去访问这块内存，对这块内存进行读写操作。

当一个指针变量保存的是一个普通变量的地址时，我们称这个指针是指向这个变量的指针。指针变量可以保存任意类型变量的地址：数组、结构体、函数甚至是另一个指针变量的地址。当一个指针变量保存的是另一个指针变量的地址，我们称该指针是指向指针的指针，或者叫做二级指针。

    #include <stdio.h>

    int main(void)
    {
        int a = 10;
        int *p = &a;
        int **pp = &p;

        printf("    a : %d\n", a);
        printf("   *p : %d\n", *p);
        printf(" **pp : %d\n", **p);
        printf("\n");

        printf("&a: %p, a: %d\n", &a, a);
        printf("&p: %p, p: %p\n", &p, p);
        printf("&pp: %p, pp: %p\n", &pp, pp);
        printf("\n");
        return 0;
    }

程序运行结果

        a:10
       *p:10
     **pp:10

     &a:0xbfda6d30  a:10
     &p:0xbfda6d34  p:0xbfda6d30
     &pp:0xbfda6d38 pp:0xbfda6d34

二级指针的用处：
- 修改指针变量的值
- 指针数组传参
- 操作二维数组

在下面的三节中一一详解

## 修改指针变量的值

    void change(int *p)
    {
        (*p)++;
        p++;
    }

函数的参数传递是传值调用，传给函数形参的值其实是实参变量的副本。将地址作为参数传递，称为传址调用，但是传址调用，也是无法通过在函数内对指针进行加减改变实参的地址，如`change()`函数中的`p++`。因为，传递给形参变量的地址其实也是实参变量的一个副本。


通过一级指针，可以修改一个普通变量的值，但是如果想要修改一个指针变量，则可以通过二级指针。

    #include <stdio.h>

    int a = 10;
    int b = 20;

    void change(int **pp)
    {
        *pp = &b;
    }
    
    int main(void)
    {
        int *p = NULL;
        p = &a;
        printf("*p = %d\n", *p);
        change(&p);
        printf("*p = %d\n", *p);
        return 0;
    }

程序运行结果如下：

    *p = 10
    *p = 20

## 二维指针和指针数组

当数组名作为函数的参数时：
- 一维数组：数组名会隐式转换为数组首元素的地址，即一级指针；
- 指针数组：数组名也会隐式转换为首元素的地址，即指针的地址，二级指针。

|实参|可以匹配的实参|
|-|-|
|`int a[5]`|`f(int a[], int len)`/`f(int *p, int len)`|
|`int *a[5]`|`f(int *a[], int len)`/`f(int **p, int len)`|

    #include <stdio.h>

    char *season = {"Spring", "Summer", "Autumn", "Winter"};

    void array_print1(char *a[], int len)
    {
        int i;
        for(i = 0; i<len; i++)
        {
            printf("%s\n", a[i]);
        }
    }

    void array_print2(char **a, int len)
    {
        int i;
        for(i =0; i<len; i++)
        {
            printf("%s\n", a[i]);
        }
    }

    int main(void)
    {
        array_print1(season, 4);
        puts("");
        array_print2(season, 4);
        return 0;
    }

程序运行结果：

    Spring
    Summer
    Autumn
    Winter
    Spring
    Summer
    Autumn
    Winter

指针数组和二级指针做为函数的参数时，两者是等价的。`main()`函数的有参函数原型，也有两种写法。

    int main(int argc, char *argv[]);
    int main(int argc, char **argc);


## 二级指针和二维数组

一维数组的数组元素类型为`int`，则称这个数组为整型数组；一维数组的数组元素是结构体，则称这个数组为结构体数组；一维数组的数组元素还是一个数组，则称之为二维数组。

C语言是把二维数组当做一个特殊的一维数组来处理的，每个元素都是一个一维数组。

    int a[5] = {1, 2, 3, 4, 5};
    int *p = a;             // p=&a[0]

    int b[3][5]={
        1,2,3,4,5,
        6,7,8,9,0,
        3,3,3,3,3
    };
    int **pp = b;           //相当于pp=&b[0]，报错

上述的第二个赋值编译会报错，因为`b[0]`是一个长度为5的数组。会出现类型不匹配的错误。

    int b[3][5]={
        1,2,3,4,5,
        6,7,8,9,0,
        3,3,3,3,3
    };

    int main(void)
    {
        int i,j;
        int (*p)[5];
        p = b;
        for(i=0; i<3; i++)
        {
            for(j=0; j<5; j++)
            {
                printf("%d ", p[i][j]);
            }
            puts("");
        }
        return 0;
    }

也可以使用二级指针来操作二维数组。

    int a[3][5]={
        1,2,3,4,5,
        6,7,8,9,0,
        3,3,3,3,3
    };

    int main(void)
    {
        int i,j;
        int (*p)[5];
        p = a;
        int (**pp)[5];
        pp = &p;
        for(i=0; i<3; i++)
        {
            for(j=0; j<5; j++)
            {
                printf("%d ", (*pp)[i][j]);
            }
            puts("");
        }
        return 0;
    }

也可以使用一级指针来访问二维数组

    int a[3][5]={
        1,2,3,4,5,
        6,7,8,9,0,
        3,3,3,3,3
    };

    int main(void)
    {
        int i,j;
        int (*p)[5];
        p = a;                  //&a[0]
        int *pt = &a[0];        //&a[0][0]
        for(i=0; i<3; i++)
        {
            for(j=0; j<5; j++)
            {
                printf("%d ", *(pt+i*5+j));     //pt+1指向a[0][1]
            }
            puts("");
        }
        return 0;
    }

上面的三个程序的输出结果都是

    1 2 3 4 5
    6 7 8 9 0
    3 3 3 3 3

在使用指针操作数组是，无论操作一维数组还是二维数组，定义的指针类型不同，操作数组的方式也不同。

一维数组作为函数的参数，可以匹配的函数形参有下面两种形式

    void array_print(int a[], int len);
    void array_print(int *a, int len);

二维数组作为函数的参数，可以写成下面的两种形式

    void array_print(int a[][5], int len);
    void array_print(int (*a)[5], int len);

|实参|可以匹配的实参|
|-|-|
|`int a[5]`|`f(int a[], int len)`/`f(int *p, int len)`|
|`int *a[5]`|`int **p`/`int *a[]`|
|`int (*p)[5]`|`int (*p)[5]`|
|`int a[4][5]`|`int (*p)[5]`|
|`int **p`|`int **p`|

# 函数指针

指针类型主要分为3种：对象指针，函数指针和`void*`指针。

函数指针调用示例

    int func(void);         //函数定义声明
    int (*fp)(void);        //定义一个函数指针，指向的函数类型为int f(void)
    fp = func;              //将函数func的入口地址赋值给指针变量
    (*fp)();                //通过函数指针调用函数
    fp();                   //函数指针的简化使用形式

函数名的本质就是指向函数的指针常量，即函数的入口地址。在`fp = func`的表达式中，函数名会通过隐式转化成`fp = &func`的形式。无论是间接访问，还是多次间接访问，效果都一样，都是`fp()`

    (***fp)();
    (**fp)();
    (*fp)();
    fp();

指针函数指函数的类型，即函数的返回值的一个指针。除此之外和普通函数无异。

    int *func(int a, int b);

# void

`void`经常用来修饰函数的返回类型，。`void`作为时，。

|`void`|说明|
|-|-|
|作为函数的返回值|表明函数无返回值类型|
|作为函数的参数|表明函数无参数|
|`void*`指针|<li>可以指向任意数据类型；<li>任何类型指针可以直接赋值给`void*`指针，无需强制类型转换；<li>`void*`指针赋值给其他类型指针时，需要进行强制类型转化；<li>任意类型的指针转换为`void*`型指针时，都不会发生数据丢失，值也不会发生改变；<li>`void*`指针做为函数的参数，表示函数的参数可以是任意指针类型；<li>函数的返回值为`void*`类型时，返回的指针可以指向任意数据类型|

`void*`不能使用间接访问运算符`*`访问`void*`，不能对`void*`做下标运算。

|空指针|`void*`|`NULL`|
|-|-|-|
|不指向任何对象，值为`NULL`|`void*`指向的对象不属于任何类型，任何时候都可以使用其他类型的指针代替`void*`或者`void*`代替任何类型的指针|`NULL`是一个`<stddef.h>`中的宏，与任意有效指针值均不同|