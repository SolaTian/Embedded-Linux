# ARM体系结构

计算机指令集分为4种：
1. 复杂指令集（CISC）
2. 精简指令集（RISC）
3. 显示并行指令集（EPIC）
4. 超长指令字指令集（VLIW）

`RISC`指令集相对于`CISC`指令集，具有以下特点：
- `Load/Store`架构，`CPU`不能直接处理内存中的数据，要先将内存中的数据`Load`到寄存器才可以进行操作，然后将处理结果`Store`到内存中；
- 固定的指令长度、单周期指令；
- 倾向于使用更多的寄存器来存储数据，而不是使用内存中的堆栈，效率更高。

|`ARM`处理器模式|说明|
|-|-|
|`User mode`|应用程序正常运行的工作模式|
|`FIQ mode`|快速中断模式，中断优先级比`IRQ`高|
|`IRQ mode`|中断模式|
|`Supervisor mode`|管理模式，保护模式，复位和软中断一般会进入该模式|
|`Abort mode`|数据存取异常，指令读取失败时会进入该模式|
|`Undefined mode`|`CPU`遇到无法识别、未定义的指令时，会进入该模式|
|`System mode`|类似于用户模式，但可以运行特权`OS`任务，如切换到其他模式|
|`Monitor mode`|仅限于安全扩展|

除了用户模式以外，其他的都是特权模式。

应用程序正常运行时，处理器处于普通模式，没有权限对内存和底层硬件进行操作。如果应用程序要读写磁盘上的数据，驱动声卡等设备，往屏幕上写歌词，需要首先通过系统调用或软中断进入特权处理模式，运行操作系统内核或硬件驱动代码，才能对底层的硬件设备进行读写操作。


|`ARM`寄存器分类|说明|
|-|-|
|通用寄存器|`R0-R12`，除了`FIQ`模式，在其他模式下这些寄存器都是共用的、共享的。<li>`R0-R3`通常用来传递函数参数；<li>`R4-R11`用来保存程序运算中间结果或函数的局部变量等；<li>`R12`通常用来作为函数调用过程中的临时寄存器。|
|专用寄存器|在各自的工作模式下独立存在的。<li>`R13`堆栈指针寄存器（`SP`）用来维护和管理函数调用过程中的栈帧变化，`R13`总是指向当前正在运行的函数的栈帧，一般不做其他用；<li>`R14`链接寄存器（`LR`），在函数调用的过程中主要用来保存上一级函数调用者的返回地址；<li>`R15`程序计数器（`PC`），`CPU`从内存取指令执行，就是默认从`PC`保存的地址中取的，每一次取指令，`PC`寄存器的地址值自动增加；<li>`CPSR`当前状态寄存器：用来表征当前处理器的运行状态，除了各种状态位和标志位，`CPSR`寄存器中也会有许多控制位，用来切换处理器的工作模式和终端使能控制；<li>每种工作模式下，都有一个单独的程序状态保存寄存器（`SPSR`）。当`ARM`处理器切换工作模式或发生异常时，`SPSR`用来保存当前工作模式下的处理器现场，即将`CPSR`寄存器的值保存到当前工作模式下的`SPSR`寄存器，当`ARM`处理器从异常返回时，就可以从`SPSR`寄存器中恢复原来的处理器状态，切换到原来的工作模式继续运行。|

# ARM汇编指令

`ARM`指令格式：

    <opcode> {<cond> {s} <Rd>,<Rn>{,<operand2>}}

说明：
- <>：表示必选项
- {}：表示可选项
- < opcode>：二进制操作码助记符
- cond：执行条件
- s：是否影响`CPSR`中的标志位
- Rd：目标寄存器
- Rn：第一个操作数的寄存器
- operand2：第二个可选操作数

## 存储访问指令

`ARM`处理器属于冯.诺依曼结构，程序和数据都在同一存储器上，内存空间和`I/O空间`统一编址。`ARM`处理器对于程序指令、数据、`I/O空间`中的外设寄存器的访问都要通过`Load/Store`指令来完成。

    LDR R1,[R0];    将R0中的值作为地址，将该地址上的数据保存到R1
    STR R1,[R0];    将R0中的值作为地址，将R1中的值存储到这个内存地址
    LDRB/STRB;      每次读写一字节，LDR和STR默认每次读写四字节
    LDM/STM;        批量加载/存储指令，在一组寄存器和一片内存之间传输数据
    SWP R1,R1,[R0]  将R1与R0中地址指向的内存单元中的数据进行交换
    SWP R1,R2,[R0]  将[R0]存储到R1，将R2写进[R0]这个内存存储单元

在一个内存堆栈结构中，如果堆栈指针`SP`总指向栈顶元素，那么这个栈就是满栈；如果`SP`指向的是栈顶元素下一个空闲的存储单元，那么这个栈就是空栈。每入栈一个元素，`SP`就会向栈增长的方向移动一个存储单元。

|栈分类|说明|
|-|-|
|`FA`|满递增堆栈，`SP`由低地址向高地址移动|
|`FD`|满递减堆栈，`SP`由高地址向低地址移动，`ARM`处理器一般使用的都是满递减堆栈|
|`EA`|空递增堆栈|
|`ED`|空递减堆栈|

    LDMFD SP!,{R0-R2,R14}       ;将内存栈中的数据依次弹到R14,R2,R1,R0
    STMFD SP!,{R0-R2,R14}       ;将R0,R1,R2,R14依次压入内存栈
                                ;或者使用POP和PUSH
    PUSH {R0-R2,R14}            ;将R0,R1,R2,R14依次压入栈
    POP {R0-R2,R14}             ;将栈中的数据依次弹出到R14,R2,R1,R0

在入栈语句中，会按照大括号中从左往右入栈；在出栈语句中，会按照大括号中从右往左弹出。

## 数据传送指令

`LDR`和`STR`用来在寄存器和内存之间传输数据，在寄存器之间传送数据，可以使用`MOV`指令。

    MOV {cond} {s} Rd, operand2
    MVN {cond} {s} Rd, operand2

`{cond}`为条件指令可选项，`{s}`表示是否影响`CPSR`寄存器的值，如`MOVS`指令就会影响，而`MOV`指令不会影响。`MVN`用来将操作数`operand2`按位取反后传送到目标寄存器`Rd`。操作数`operand2`可以是一个立即数，也可以是一个寄存器。

    MOV R1, #1      ;将立即数1传送到寄存器R1中
    MOV R1, #R2     ;将R0寄存器中的值传送到R1寄存器中
    MOV PC, LR      ;子程序返回
    MVN R0, #0xFF   ;将立即数0xFF取反后赋值给R0
    MVN R0, R1      ;将R1寄存器的值取反后赋值给R0


## 算术逻辑运算指令

    ADD {cond} {s} Rd, Rn, operand2    ;加法
    ADC {cond} {s} Rd, Rn, operand2    ;带进位的加法
    SUB {cond} {s} Rd, Rn, operand2    ;减法
    AND {cond} {s} Rd, Rn, operand2    ;逻辑与
    ORR {cond} {s} Rd, Rn, operand2    ;逻辑或
    EOR {cond} {s} Rd, Rn, operand2    ;异或运算
    BIC {cond} {s} Rd, Rn, operand2    ;位清除运算

    ADD R2, R1, #1          ;R2=R1+1
    ADC R2, R1, #1          ;R2=R1+1+C（C为CPSR寄存器中进位）
    SUB R1, R1, R2          ;R1=R1-R2
    SBC R1, R1, R2          ;R1=R1-R2-C
    AND R0, R0, #3          ;保留R0的bit0和1，其余位清除
    ORR R0, R0, #3          ;置位R0的bit0和1
    EOR R0, R0, #3          ;反转R0中的bit0和1
    BIC R0, R0, #3          ;清除R0中的bit0和1

## 操作数：operand2

`ARM`指令的第2个参数`operand2`可以是一个常数，也可以是寄存器+偏移的形式

    #constant
    Rm{, shift}

    #constant n     ;将立即数constant循环右移n位
    ASR #n          ;算术右移n位，n的取值范围为[1,32]
    LSL #n          ;逻辑左移n位，n的取值范围为[0,31]
    LSR #n          ;逻辑右移n位，n的取值范围为[1,32]
    ROR #n          ;向右循环移n位，n的取值范围为[1,31]
    RRX             ;向右循环移1位，带扩展

    ADD R3, R2, R1, LSL #3      ;R3=R2+R1<<3
    ADD R3, R2, R1, LSL R0      ;R3=R2+R1<<R0
    ADD IP, IP, #16, 20         ;IP=IP+立即数16循环右移20位

## 比较指令

比较两个数的大小。比较指令的结果会影响到`CPSR`寄存器的`N`、`Z`、`C`、`V`标志位。

    CMP {cond} Rn, operand2     ;比较两个数的大小
    CMN {cond} Rn, operand2     ;取负比较

    CMP R1, #10     ;R1-10，比较结果影响到N、Z、C、V位
    CMP R1, R2      ;R1-R2，比较结果影响到N、Z、C、V位
    CMN R0, #1      ;R0-(-1)，将立即数取负，然后比较大小

比较指令运行结果`Z=1`时，表示运算结果为0，两个数相等；`N=1`表示运算结果为负，`N=0`表示运算结果为非负。


## 条件执行指令

无条件跳转指令`B`可以在后面加上条件码组成`BEQ`、`BNE`组合指令。

`BEQ`指令表示两个数比较，结果相等时跳转；`BNE`指令标识结果不相等时跳转。

条件执行经常出现在跳转或者循环的程序结构中。

`ARM`指令条件码
|条件码|CPSR标志位|说明|
|-|-|-|
|`EQ`|Z=1|相等|
|`NE`|Z=0|不相等|
|`CS/HS`|C=1|无符号数大于或等于|
|`CC/LO`|C=0|无符号数小于|
|`MI`|N置位|负数|
|`PL`|N清零|正数或0|
|`VS`|V置位|溢出|
|`VC`|V清零|未溢出|
|`HI`|C置位，Z清零|无符号数大于|
|`LS`|C清零，Z置位|有符号数小于或等于|
|`GE`|N=V|有符号数大于或等于|
|`LT`|N!=V|有符号数小于|
|`GT`|Z清零，N=V|有符号数大于|
|`LE`|Z置位，N!=V|有符号数小于或等于|
|`AL`|忽略|无条件执行|
|`NV`|忽略|从不执行|
## 跳转指令

在函数调用的场合，以及循环结构，分支结构的程序中经常会用到跳转指令。

    B {cond} label      ;跳转到label处执行
    B {cond} Rm         ;寄存器Rm中保存的是跳转地址
    BL {cond} label
    BX {cond} label
    BLX {cond} label

### B label
无条件跳转指令`B`的跳转范围为0-32MB，可以往前跳，也可以往后跳，主要用在循环、分支结构中

    CMP R2, #0
    BEQ label       ;若R2=0，则跳转到label处执行
    ...
label
    ...

### BL label
`BL`表示带链接的跳转。在跳转之前，`BL`指令会先将当前指令的下一条指令地址（即返回地址）保存到`LR`寄存器中，然后跳转到`label`处执行。

    ;主程序
        ...
        BL subfunc          ;调到subfunc执行，跳之前先将返回地址保存到LR
        ...                 ;子程序返回后接着从此处继续执行
    ;子程序
    subfunc
        ...
        MOV PC, LR          ;子程序执行完成，将返回地址赋值给PC，返回到主函数

### BX Rm

`BX`表示带状态切换的跳转。`Rm`寄存器中保存的是跳转地址，要跳转的目标地址处可能是`ARM`指令，也可能是`Thumb`指令。处理器会根据`Rm[0]`位决定是切换到`ARM`状态还是切换到`Thumb`状态。

`Thumb`指令集是`ARM`体系的结构的扩展。

- 0：表示目标地址处是`ARM`指令，在跳转之前要先切换到`ARM`状态
- 1：表示目标地址处是`Thumb`指令，在跳转之前要先切换成`Thumb`状态

# ARM寻址方式

## 寄存器寻址

> 操作数保存在寄存器中，通过寄存器名就可以直接对寄存器中的数据进行读写。

    MOV R1, R2      ;将寄存器R2的值传送到R1中
    SUB R1, R2, R3  ;运行减法R2-R3，将结果保存到R1中


## 立即数寻址

> 立即数以`#`为前缀，0x前缀表示该立即数为十六进制，不加前缀默认是十进制。

    ADD R1, R1, #1          ;将R1寄存器中的值加1，并将结果保存到R1中
    MOV R1, #0xFF           ;将十六进制常数0xFF写到寄存器R1中
    MOV R1, #12             ;将十进制常数12放到R1寄存器中
    ADD R1, R1, #16, 20     ;R1=R1+立即数16循环右移20位

## 寄存器偏移寻址

> 寄存器偏移寻址可以看做是寄存器寻址的一种特例，通过第二个操作数做左移右移操作

    MOV R2, R1, LSL #3      ;R2=R1<<3
    ADD R3, R2, R1, LSL #3  ;R3=R2+R1<<3
    ADD R3, R2, R1, LSL R0  ;R3=R2+R1<<R0

移位分为逻辑移位和算术移位，区别在于：
- 逻辑移位无论是左移还是右移，空缺位一律补0；
- 算术移位左移时空缺补0，右移时空缺使用符号位填充；


## 寄存器间接寻址

> 寄存器间接寻址主要用来在内存和寄存器之间传输数据。寄存器中保存的是数据在内存中的存储地址，通过这个地址就可以在寄存器和内存之间传输数据。

C语言的指针操作，在汇编层次就是使用寄存器间接寻址实现的。


    LDR R1, [R2]        ;将R2中的值作为地址，取该内存地址上的数据，保存到R1
    STR R1, [R2]        ;将R2中的值作为地址，将R1寄存器的值写入该内存地址


## 基址寻址

> 基址寻址属于寄存器间接寻址，不同点在于，基址寻址将寄存器中的地址与一个偏移量相加，生成一个新地址，然后基于这个新地址去访问内存。

    LDR R1, [FP, #2]        ;将FP中的值加2作为新地址，取该地址上的值保存到R1
    LDR R1, [FP, #2]!       ;FP=FP+2，然后将FP指定的内存单元数据保存到R1中
    LDR R1, [FP, R0]        ;将FP+R0作为新地址，取该地址上的值保存到R1 
    LDR R1, [FP, R0, LSL #2];将FP+R0<<2作为新地址，读取该内存地址上的值保存到R1
    LDR R1, [FP], #2        ;将FP中的值作为地址，取该地址的值保存到R1，然后FP中的值加2
    STR R1, [FP, #-2]       ;将FP中的值减2，作为新地址，将R1中的值写入该地址
    STR R1, [FP], #2        ;将FP中的值作为地址，将R1寄存器的值写入该内存地址，然后FP中的值减2

## 多寄存器寻址

> STM/LDM指令属于多寄存器寻址，一次可以传输多个寄存器的值。

    LDMIA SP!, {R0-R2, R14}     ;将内存栈中的数据依次弹出到R14，R2，R1，R0
    STMDB SP!, {R0-R2, R14}     ;将R0，R1，R2，R14依次压入栈
    LDMFD SP!, {R0-R2, R14}     ;将内存栈中的数据依次弹出到R14，R2，R1，R0
    STMFD SP!, {R0-R2, R14}     ;将R0，R1，R2，R14依次压入栈

在多寄存器寻址中，用大括号{}括起来的是寄存器列表，寄存器之间用逗号隔开，如果是连续的寄存器，还可以使用连接符`-`连接。

`LDM/STM`指令一般和`IA`，`IB`，`DA`，`DB`组合使用，分别表示Increase After，Increase Before，Decrease After，Decrease Before。`LDM/STM`指令还可以和`FD`，`ED`，`FA`，`EA`组合使用，用于堆栈操作。

函数内的局部变量，函数调用过程中要传递的参数，函数的返回值一般都是保存在栈中。在部分嵌入式系统的一些启动代码中，在运行C语言程序之前，必须要先运行一段汇编代码初始化内存和栈指针`SP`，然后才可以跳到C语言程序中运行。

栈一般可以分为4类：

- 递增栈A：入栈时，`SP`栈指针从低地址往高地址方向增长；
- 递增栈D：入栈时，`SP`栈指针从高地址往低地址方向增长；
- 满栈F：`SP`栈指针总是指向栈顶元素；
- 空栈E：`SP`栈指针总是指向栈顶元素的下一个空闲存储单元。

`ARM`默认使用满递减堆栈，通过`STMFD/LDMFD`指令配对使用，完成堆栈的入栈和出栈操作。`ARM`的`PUSH`和`POP`指令就是`LDM`和`STM`的同义词，是`LDMFD`和`STMFD`组合指令的助记符。

    STMFD SP!, {R0-R2, R14}     ;将R0，R1，R2，R14依次压入栈
    LDMFD SP!, {R0-R2, R14}     ;将栈中的数据依次弹出到R14，R2，R1，R0
    PUSH {R0-R2, R14}           ;将R0，R1，R2，R14依次压入栈
    POP {R0-R2, R14}            ;将栈中的数据依次弹出到R14，R2，R1，R0


## 相对寻址

> 相对寻址也属于基址寻址，只不过是一种特殊情况，它是以`PC`指针作为基地址进行寻址的，以指令中的地址差作为偏移，两者相加后得到的就是一个新地址，然后对这个地址进行读写操作。

`B`，`BL`，`ADR`指令都是采用的相对寻址

         ...
         B LOOP
         ...
    LOOP MOV R0, #1
         MOV R1, R0
         ...

上述例子中，`B LOOP`就相当于

    ADD PC, PC, #OFFSET     ;OFFSET表示当前正在执行的指令地址和地址标号LOOP之间的地址偏移

`B`的跳转范围为[0，32MB]，只要编写的程序生成的二进制文件小于32MB，基本上就可以随意地使用`B`指令跳转。


动态库链接，在汇编代码层次的实现其实也是采用的相对寻址。程序中使用相对寻址的访问的好处是不需要重定位，将代码加载到内存中的任何地址都可以运行。

# ARM伪指令

`ARM`伪指令不是标准指令，是编译器厂商定义的一些辅助指令，类似于C语言中的预处理指令。程序编译时，这些伪指令会被翻译成一条或者多条`ARM`标准指令。

伪指令主要有4个：`ADR`，`ADRL`，`LDR`，`NOP`

    ADR R0, LOOP        ;将标号LOOP的地址保存到R0寄存器中
    ADRL R0, LOOP       ;中等范围的地址读取
    LDR R0, =0x30008000 ;将内存的地址0x30008000赋值给R0
    NOP                 ;空操作，用于延时或插入流水线中暂停指令的运行

## LDR伪指令

`LDR`伪指令和`LDR`加载指令名称一样，其主要作用是将一个32位的内存地址保存到寄存器中。

在寄存器之间传递数据可以使用`MOV`指令，但是当传递的内存地址是一个32位的立即数时，`MOV`指令就应付不了

    MOV R0, #200        ;往寄存器传递一个立即数，指令正常
    MOV R0, #0x30008000 ;往寄存器传递一个32位的立即数，指令异常

在一个32位系统中，一条指令通常是32位的，指令中包括操作码和操作数，这个32位存储空间是共享的，操作码要占据几个比特位，剩下的留给操作数的编码空间就小于32位了。所以上述的第2条指令就会异常。编译器提供了`LDR`伪指令来完成上面的功能。

    LDR R0, =0x30008000

为了与`LDR`加载指令区分，在伪指令的操作数前面一般会有一个`=`，通过`LDR`伪指令，编译器就解决了向一个寄存器传送32位的立即数时指令无法编码的难题。这些伪指令不会被`CPU`的硬件译码电路直接运行，在编译的时候会被`ARM`标准指令代替。当`LDR`伪指令操作小于8位时，`LDR`伪指令就会被`MOV`指令替代。当操作数大于8位时，`LDR`伪指令会被编译器转换为`LDR`标准指令+文字池的形式。

    LDR R0, =0x30008000         ;伪指令
    
    LDR R0, [PC, #OFFSET]       ;翻译成的标准指令
    ...
    ...
    DCD 0x30008000              ;文字池

编译器首先会在内存中分配一个4字节大小的存储单元，然后将32位的地址存放到该存储单元中，该存储单元叫做文字池，接着编译器计算出该存储单元到`LDR`伪指令之间的偏移，然后使用寄存器相对寻址，就可以将这个32位立即数送到`R0`寄存器中。偏移量`OFFSET`的大小一般要小于4KB。


## ADR伪指令

`ADR`伪指令的功能与`LDR`伪指令类似，将基于`PC`相对偏移的地址值读取到寄存器中。`ADR`为小范围的地址读取伪指令，底层使用相对寻址来实现，因此可以做到代码与位置无关。

    ADR R0, LOOP
    ...
    ...
    LOOP 
        b LOOP

编译器在编译`ADR`伪指令时，会首先计算出来当前正在执行的`ADR`伪指令和标号`LOOP`之间的地址偏移，然后使用`ARM`的一条标准指令代替，如使用`ADD`指令将标号表征的地址送到寄存器`R0`中。

    OFFSET = LOOP-(PC-8)
    ADD R0, PC, #OFFSET

`ADR`和`LDR`的伪指令相似之处在于：两者都是加载一个地址到指定的寄存器中；不同之处在于：`LDR`伪指令，而`ADR`伪指令。
不同点：
|`LDR`|`ADR`|
|-|-|
|主要用来操作外部设备的寄存器|主要通过相对寻址，生成与位置无关的代码，只要标号之间的相对位置不变，就可以将指令加载到内存中的任何位置正常运行|
|使用绝对地址|使用相对寻址|
|适用的地址范围为[0，32GB]|要求伪指令和标号必须在同一个段中，地址偏移范围较小，地址对齐时偏移范围为[0，1020]，地址未对齐时偏移范围为[0，4096]|
|通常会被翻译成`LDR`或者`MOV`指令|通常会被`ADD`或`SUB`指令代替|

# ARM汇编程序设计

## `ARM`汇编程序格式

`ARM`汇编程序是以`段（section）`为单位进行组织的，在一个汇编文件中，可以有不同的`section`，分为代码段、数据段等，各个段之间相互独立。可以使用`AREA`伪操作来标识一个段的起始，段名和段的读写属性。

    AREA COPY,CODE,READONLY     ;当前段属性为代码段，只读，段名为COPY
    ENTRY                       ;伪操作ENTRY来标识汇编程序的的运行入口
    ...
    ...
    AREA COPYDATA, DATA, READWRITE  ;数据段，读写权限，段名为COPYDATA
    ...
    END                         ;伪操作END标识汇编程序的结束

## 符号与标号

在`ARM`汇编中，可以用符号来标识一个地址、变量或者数字常量。当用符号来标识一个地址时，这个符号通常被称为标号。

符号由字母、数字和下划线组成，符号开头不可以是数字，但是标号除外，标号的开头可以是数字，甚至整个标号都是数字。


有时候通过数字[0,99]而不是字符进行地址引用，称这种数字为局部标号。局部标号的作用域为当前段，可以通过下面的格式来引用局部标号。

    %{F|B|A|T} N{routename}

大括号`{}`是可选项，`N`表示局部标号，其余说明如下：
- `%`：引用符号，对一个局部标号产生引用
- `F`：指示编译器只向前搜索
- `B`：指示编译器只向后搜索
- `A`：指示编译器搜索宏的所有宏命令层
- `T`：指示编译器搜索宏的当前层
- `N`：局部标号的名字
- `routename`：局部标号作用范围名称，使用`ROUT`定义。

若`B`和`F`都没有指定，则编译器将默认先向后搜索，然后向前搜索。若`A`和`T`都没有指定，则汇编程序默认搜索当前层到最顶层的所有宏命令，但不搜索较低层的宏命令。如果在标签中或者对一个标签的引用中指定了`routename`，则汇编程序将其与最近的一个前`ROUT`指令的名称进行比较，如果不匹配，则汇编失败

    AREA COPY,CODE,READONLY
        ENTRY
    START
        LDR R0,=SRC
        LDR R1,=DST
        MOV R2,#10
    0
        LDR R3,[R0],#4
        STR R3,[R1],#4
        SUBS R2,R2,#1
        BNE %B0     ;跳到前面的局部标号0处，构成循环结构
    AERA COPYDATA,DATA,READWRITE
    SRC DCD 1,2,3,4,5,6,7,8,9,0
    DST DCD 0,0,0,0,0,0,0,0,0,0
        END
  

## 伪操作

除了前面提到的伪操作，还有使用`GBLA`来定义一个数据。即使在同一个`CPU`架构下，不同的编译环境或汇编器虽然会遵循和兼容同一套指令集，但是可能会定义不同的伪操作。

    GBLA a      ;定义一个全局算术变量a，并初始化为0
    a SETA 10   ;给算术变量a赋值10
    GBLL b      ;定义一个全局逻辑变量b，并初始化为{false}
    b SETL 20   ;给逻辑变量b赋值20
    GBLS STR    ;定义一个全局字符串变量STR，并初始化为0
    STR SETS "ss"   ;给字符串变量STR赋值为"ss"
    LCLA a      ;定义一个局部算术变量a，并初始化为0
    LCLL b      ;定义一个局部逻辑变量b，并初始化为{false}
    LCLS name   ;定义一个局部字符串变量name，并初始化为0
    name SETS "ss" ;给局部字符串变量赋值

关于数据定义，常用的伪操作有`DCD`，`DCB`，`SPACE`，`DATA`，这些伪操作的使用方法如下

    DATA1 DCB 10,20,30,40      ;分配一片连续的字节存储单元并初始化
    STR DCB "ss"               ;给字符串分配一片连续的存储单元并初始化
    DATA2 DCD 10,20,30,40      ;分配一片连续的字存储单元并初始化
    BUF SPACE 100              ;给BUF分配100字节的存储单元并初始化为0

    IMPORT sum

    AREA SUM_ASM,CODE,READONLY
        EXPORT SUM_ASM
    SUM_ASM
        STR LR,[SP,#-4]     ;保存调用者的返回地址
        LDR R0,=0x3
        LDR R1,=0x4
        BL sum              ;调用其他文件里的子文件
        LDR PC,[SP],#4      ;返回主程序，继续运行
        END
汇编子程序`SUM_ASM`，使用`EXPORT`伪操作将其声明为一个全局符号，然后其他汇编程序或C程序就可以直接调用。

`SUM_ASM`本身调用了其他子程序`sum`，这个`sum`程序可以是一个汇编子程序，也可以是一个使用C语言的函数。在调用之前，先要使用`IMPORT`伪操作把`sum`子程序导入进来，然后通过`BL`指令跳转过去。只要符合规则，汇编程序和C程序可以相互调用，从汇编指令的层面上看，它们无本质区别。

|伪操作|说明|
|-|-|
|`ALIGN`|地址对齐|
|`AREA`|定义一个代码段或者数据段，常用的段属性为`CODE/DATA`|
|`CODE16/CODE32`|指示编译器后面的指令为`THUMB/ARM`|
|`ENTRY`|指定汇编程序的入口|
|`END`|用来告诉编译器源程序已到结尾，停止编译|
|`EQU`|赋值伪指令，类型宏，给常量定义一个符号名|
|`EXPORT/GLOBAL`|声明一个全局符号，可以被其他文件引用|
|`IMPORT/EXTERN`|引用其他文件的全局符号，要先`IMPORT`|
|`GET/INCLUDE`|包含文件，并将该文件当前位置进行编译，一般包含的是程序文件|
|`INCBIN`|包含文件，但不编译，一般包含的是数据、配置文件等|

# C语言和汇编语言混合编程

在一些嵌入式场合中，会有C语言和汇编程序相互调用、混合编程。如`ARM`启动代码，系统一启动首先运行汇编代码，等初始化好内存堆栈环境之后，才会跳到C程序中执行。同样在一些性能要求较高的场合，通常会在C语言程序中内嵌一些汇编代码。

## ATPCS规则

从指令集层面看C语言和汇编语言，两者并无根本差别，都是指令集的不同程度封装而已，最终都会被翻译成二进制指令。

`ATPCS`规则定义了`ARM`子程序的调用基本规则以及堆栈的使用约定等。

- 子程序间要通过寄存器`R0`-`R3`传递参数，当参数个数大于4时，剩余的参数使用堆栈来传递
- 子程序通过`R0`-`R1`返回结果
- 子程序中使用`R4`-`R11`来保存局部变量
- `R12`作为调用过程中的临时寄存器，记作`IP`
- `R13`作为堆栈指针寄存器，一般记作`SP`
- `R14`作为链接寄存器，用来保存函数调用者的返回地址，记作`LR`
- `R15`作为程序计数器，总是指向当前正在运行的指令，记作`PC`


下面的C程序中，直接调用了`SUM_ASM`汇编子程序，汇编程序中又调用了C语言的`sum()`

    //main.c
    int sum(int a, int b)
    {
        int result = 0;
        result = a+b;
        printf("result = %d\n", result);
        return result;
    }

    int main(void)
    {
        SUM_ASM();
        return 0;
    }

    //SUM.S
    IMPORT sum;
    AREA SUM_ASM,CODE,READONLY
        EXPORT SUM_ASM
    SUM_ASM
        STR LR,[SP,#-4]
        LDR R0,=0x3         ;arg1-->R0，传递参数给sum
        LDR R1,=0x4         ;arg2-->R1，传递参数给sum
        BL sum
        LDR PC,[SP],#4
        END

## 在C程序中内嵌汇编代码

为了在C语言中内嵌汇编代码，`ARM`编译器在`ANSI C`标准的基础上扩展了一个关键字`_asm`。格式如下：

    _asm
    {
        指令   
    }

如果在内嵌的汇编代码中添加注释，需要使用C语言的注释

    //main.c
    int src[10] = {1,2,3,4,5,6,7,8,9};
    int dst[10] = 0;

    //数据块赋值的C语言实现
    int data_copy_c(void)
    {
        for(int i=0; i<10; i++)
        {
            dst[i] = src[i];
        }
        return 0;
    }

    //数据块复制的内嵌ARM汇编实现
    int data_copy_asm(void)
    {
        _asm
        {
            LDR R0,=src
            LDR R1,=dst
            MOV R2,#10
        LOOP:
            LDR R3,[R0],#4
            STR R3,[R1],#4
            SUBS R2,R2,#1
            BNE LOOP
        }
    }

在`GNU ARM`编译器中，提供了一个`_asm_`关键字，效果也是一样。在一个C程序中，如果看到一段代码使用`_asm_`修饰，则表示这段代码为内嵌汇编，`_asm_`后面还可以用`_volatile_`关键字来修饰用来告诉编译器不要优化这段代码。

## 在汇编程序中使用C程序

可以参考`ATPCS`规则中的例子，汇编程序中调用C程序。在函数调用的过程中，当要传递的参数个数大于4个时，除了前4个参数使用寄存器`R0`-`R3`传递，剩余的参数需要使用堆栈进行传递。

# GNU ARM 汇编语言

嵌入式开发不同的`IDE`分类：
- `IDE`中集成了`ARM`编译器
- 使用开源的`GNU GCC for ARM`编译器，简称`GNU ARM`编译器

## 重新认识编译器

一套完整的编译工具主要包括：
1. 编译器：用来将C源文件编译成汇编文件
2. 汇编器：用来将汇编文件汇编成目标文件
3. 链接器：用来将目标文件组装成可执行文件
4. 二进制转化工具：`objdump`，`objcopy`，`strip`等
5. 库打包工具：`rar`等
6. 调试工具：`gdb`，`run`
7. 库/头文件，根据C语言标准定义的`API`实现的C标准库及对应的头文件。

各个厂商的编译器因为遵循同一套`ARM`指令集标准，因此经过不同的编译器编译的程序都可以在同一台`ARM`处理器上运行。市面上各种`ARM`编译器之间的唯一区别就是汇编指令的格式有所差异，造成差异的原因是各家编译器厂商各自扩展的伪操作不同。

## GNU ARM编译器的伪操作

|常用的`GNU ARM`编译器伪操作|说明|
|-|-|
|`ENTRY(_start)`|定义汇编程序的执行入口|
|`@`、`#`|代码的注释，整行注释符号|
|`.section .text`，`"x"`|定义一个段，a只读；w读写；x执行|
|`.align`，`.balign`|地址对齐方式，按照指定字节数对齐|
|`label:`|标号，以冒号结尾|
|`.byte`|把字节插入目标文件|
|`.quad`，`.long`，`.word`，`.byte`，`.short`|分配不同大小的存储空间，插入目标文件|
|`.string`，`.ascii`，`.asciz`|重新定义字符串，字符，以`NULL`结尾的字符串|
|`.rept`，`endr`|重复定义|
|`.float`|浮点数定义|
|`.space 10 FF`|分配一片连续的10字节空间，填充为FF|

很多，不一一列举，可以参考书籍《嵌入式C语言的自我修养》[Page108]或者百度


## GNU ARM汇编语言中的标号

`GNU ARM`编译器除了遵循标识符的一般规则，还有一些不同点。

`GNU ARM`汇编语言中的标识符可以由字母、数字、下划线和`.`组成，局部标号可以由纯数字`N`组成，在引用时使用`Nf`或者`Nb`的形式，分别表示向前搜索或者向后搜索。`GNU ARM`使用`_start`作为汇编程序的入口，如果你希望该标号被其他文件引用，只要在它定义的地方使用`.global`伪操作声明一下即可。

## .section 伪操作

`.section`伪操作用于自定义一个段

    .section <section name>{,"<flags>"}
    .section mysection, "awx"    @注释，定义一个可写、可执行的段
    .align

定义段名时，不能与系统预留的段名冲突，`.text`（代码段）、`.data`（数据段）、`.bss`（`BSS段`）、`.rodata`（只读数据段）。可以通过`readelf`命令来查看系统预留的段名。

    # readelf -S a.out                  --查看可执行文件的section header
    There are 13 section headers, starting at offset 0x330:
    Section Headers:
    [Nr] Name           Type        Addr       Off      Size  ES Flg Lk INf Al
    [ 0]                NULL        ...
    [ 1] .text          PROGBITS    ...
    ...
    [ 3] .data          PROGBITS    ...
    ...


## 基本数据格式

在`GNU ARM`汇编语言中，二进制数据通常以`0B`或者`0b`开头，八进制以`0`开头，十六进制以`0x`开头，十进制数据以非0开头。负数用`-`，取补用`~`，不相等用`<>`，其他运算符号与C语言相似。定义字符串常量要用双引号。

    .ascii "hello\0"                @定义字符串，需要在后面加上\0
    .string "hello", "world"        @定义多个字符串
    .asciz "hello"                  @定义一个以NULL结尾的字符串
    .rept 3 byte 0x10 .ender        @重复定义数据

`GNU ARM`汇编程序中经常使用小圆点`.`表示当前指令的地址。

## 数据定义

定义一个浮点数：

    f:
    .float 3.14         @使用.float定义一个浮点数f，为3.14
    .equ f,3.14         @使用equ将浮点数重新赋值为3.1415

`.equ`还可以把常量定义在代码段中，然后在代码中直接引用，类似于C语言的`#define`宏定义

    .section .data
    .equ DELAY,100
    ...
    .section .text
    ...
    MOV R0,$DELAY
    ...

