# 大小端与字节序

> 字节序:数据在内存或者传输过程中多字节数据的存储顺序。分为两种模式：大端序和小端序。


|字节序|定义|应用场景|
|-|-|-|
|大端序|数据的高位存储在低地址，低位存储在高地址。类似于人类阅读书写习惯，从左到右（从低地址到高地址）由高位到低位。|网络协议（TCP/IP、HTTP等）默认使用大端序（网络字节序）|
|小端序|数据的低位字节存储在低地址，高位字节存储在高地址。计算机处理更加高效。（CPU可以直接按照地址顺序从低到高读取低位到高位）|x86/x64、现代`ARM`默认小端模式(主机字节序)|


## 检测系统的字节序

下面的这段代码可以快速检测系统的字节序是大端序还是小端序。

```c
#include <stdio.h>

int main() {
    int num = 0x12345678;
    char *p = (char *)&num;
    if (*p == 0x78) {
        printf("Little-Endian\n");  // 低地址存低位字节
    } else {
        printf("Big-Endian\n");     // 低地址存高位字节
    }
    return 0;
}
```


## 主机字节序与网络字节序的转化

在头文件`<arpa/inet.h>`中有下面 4 个函数可以实现字节序的转化

```c
#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong);  // 主机→网络（32位）
uint16_t htons(uint16_t hostshort); // 主机→网络（16位）
uint32_t ntohl(uint32_t netlong);   // 网络→主机（32位）
uint16_t ntohs(uint16_t netshort);  // 网络→主机（16位）
```


## 转化实例

如何快速转换 8/16/32 位字节序

有时候会在网络抓包中看到 16 进制的网络字节序，需要转换成主机字节序查看在主机上的值是多少。

下面举几个例子

- 8位（1字节）：`0x12`，无需转换，主机字节序同网络字节序
- 16位（2字节）：`0x1234`，第2个字节和第1个字节反序，即 `0x3412`
- 32位（4字节）：`0x12345678`，将首尾字节反序，第2个和第3个字节反序，即 `0x78563412`
- 64位（8字节）：`0x1234567812345678`，首尾字节反序，第2个和倒数第2个字节反序，依次类推……得到主机字节序，即`0x7845341278563412`

