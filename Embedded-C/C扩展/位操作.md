# 位操作

> 位操作：指对整数的二进制表示进行的操作，包括位与、位或、位异或、位左移和位右移等。用于操作数据的每一位。

## 基本位操作符


|位操作符|规则|
|-|-|
|位与`&`|只有当两个对应的位都为1时，结果位才为1，否则为0。|
|位或`\|`|只要当两个对应的位中有至少一个为1时，结果位为1，否则为0|
|位异或`^`|只有当两个对应的位不同（一个是0，一个是1）时，结果位为1，否则为0|
|位取反`~`|按位取反，1取反为0，0取反为1|
|位左移`<<`|将左操作数的所有位向左移动指定的位数，左边溢出的位被丢弃，右边补0|
|位右移`>>`|将左操作数的所有位向右移动指定的位数，右边溢出的位被丢弃，左边补0（无符号数）或1（有符号数）|

## 位操作的应用

### 位掩码

#### 提取特定位——判断是否为1

> 提取特定位的核心方法：创建目标位为1，其他位为0的掩码，利用掩码与原始数据进行`&`操作。


有时需要获取变量的某个特定位的值，使用**位掩码**可以实现这个操作。

位掩码的生成需要`>>`和`<<`操作符。具体选择哪个操作符取决于生成的掩码的位置。

- 如果要生成高位掩码可以用左移`<<`，例如`1<<7`，生成第7位的掩码`0b10000000`
- 如果要生成低位掩码可以用右移`>>`，例如`1>>0`，生成第0位的掩码`0b00000001`

**注意，位的序号是从右到左，从0开始。**

获取到位掩码之后，就可以通过位与`&`获取某个特定位了。如下：

```c
//获取data的第3位
uint8_t data = 0b10101010;
uint8_t result = data & (1 << 3);   //result = 1;
```

上面的方法使用了位掩码`1<<3`生成第3位的掩码，也可以使用第0位的位掩码，但是需要对原始数据进行右移3位操作，再和第0位的掩码进行`&`操作，如下

```c
//获取data的第3位——version2
uint8_t result_2 = (data >> 3) & 0x01;
```


#### 设置特定位

> 设置特定位的核心方法：创建目标位为1，其他位为0的掩码，利用掩码与原始数据进行`|`操作。


有了上面的基础，就可以得出下面代码

```c
//设置data的第4位为1
data |=  (1 << 4);
```

如果要设置多位，就生成一个多位的掩码，分为连续位和不连续位

```c
//设置data的第3位和第5位为1（不连续位）
uint8_t mask = (1 << 3) | (1 << 5); //生成第3、5位的掩码
data |= mask;

//设置data的第3~5位为1(连续位)
uint8_t mask = ((1 << 3) - 1) << 3;   //((1 << k) - 1) << n，其中k表示需要连续设置的位数，第3位到第5位，因此是3，n 表示起始位的位置，第3位到第5位，因此，这里是3
data |= mask;
```

如果要判断是否设置成功可以将`data`与`mask`进行`&`操作。

```c
if(data & mask) {
    printf("设置成功\n");
}
else {
    printf("设置失败\n");
}
```

#### 清除特定位

> 清除特定位的核心方法是：创建目标位为0、其他位为1的掩码，与原值进行按位与`&`操作。

这个掩码其实也好办，就是将上面得到的掩码取逻辑反`~`操作。

```c
//清除data的第2位
data &= ~(1 << 2);

//清除data的第3位和第4位
data &= ~((1 << 3) | (1 << 4));

//清除data的第3~5位
uint8_t mask = ((1 << 3) - 1) << 3;
data &= ~mask;
```



