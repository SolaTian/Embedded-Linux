# 字节对齐

在计算机中，内存是以字节为基本单位进行编址的，不同类型的数据占用不同数量的字节。**字节对齐要求数据的起始地址必须是该数据类型大小的整数倍**。

## 常见的字节对齐方式

### `#pragma pack` 指令

`#pragma pack` 是一种编译器指令，用于显式控制结构体或联合体（`union`）成员的对齐方式。

### 自然对齐

> 自然对齐：指数据类型按照其自身的对齐字节数存储。

每个数据类型都有一个固定的对齐字节数：

1. `char`:1字节对齐
2. `short`:2字节对齐
3. `int`:4字节对齐
4. `float`:4字节对齐
5. `double`:8字节对齐
6. 指针：4/8 字节对齐（取决于32位或者64位）

```c
struct Example {
    char   a;     // 1字节对齐
    short  b;     // 2字节对齐
    int    c;     // 4字节对齐
    float  d;     // 4字节对齐
};
```
按照自然对齐，上面的结构体在内存中的地址和大小如下：

```mermaid
classDiagram
    class Example {
        +0x0: char a (1字节)
        +0x2: short b (2字节, 对齐填充1字节)
        +0x4: int c (4字节)
        +0x8: float d (4字节)
    }
    note for Example "总大小: 12字节（含填充）
    自然对齐规则:
    - short 起始地址需是2的倍数
    - int/float 起始地址需是4的倍数"

```

### 编译器指令对齐——1/2/4/8 字节对齐

1/2/4/8 字节指的是数据在内存中以 1/2/4/8 字节为单位进行对齐。

```c
#pragma pack(1)
struct PackedExample {
    char   a;     // 1字节对齐
    short  b;     // 2字节对齐，但被强制为1字节对齐
    int    c;     // 4字节对齐，但被强制为1字节对齐
    float  d;     // 4字节对齐，但被强制为1字节对齐
};


#pragma pack(2)
struct Packed2Example {
    char   a;     // 1字节对齐
    short  b;     // 2字节对齐
    int    c;     // 4字节对齐，但被强制为2字节对齐
    float  d;     // 4字节对齐，但被强制为2字节对齐
};

#pragma pack(4)
struct Packed4Example {
    char   a;     // 1字节对齐
    short  b;     // 2字节对齐，但被强制为4字节对齐
    int    c;     // 4字节对齐
    float  d;     // 4字节对齐
};

#pragma pack(8)
struct Packed8Example {
    char   a;     // 1字节对齐
    short  b;     // 2字节对齐，但被强制为8字节对齐
    int    c;     // 4字节对齐，但被强制为8字节对齐
    float  d;     // 4字节对齐，但被强制为8字节对齐
};
```

上面4种不同对齐方式，结构体成员在内存中的布局如下

```mermaid
classDiagram
    direction TB

    %% pack(1) - 无填充
    class PackedExample["#pragma pack(1) (无对齐填充)"] {
        +0x0: char a (1)
        +0x1: short b (2)   // 紧接a，无填充
        +0x3: int c (4)     // 紧接b，无填充
        +0x7: float d (4)   // 紧接c，无填充
        note: "总大小: 11字节（所有成员紧密排列）"
    }

    %% pack(2) - short按2字节对齐
    class Packed2Example["#pragma pack(2) (2字节对齐)"] {
        +0x0: char a (1)
        +0x1: [填充1]      // a后填充1字节，使short b从0x2开始（满足2对齐）
        +0x2: short b (2)
        +0x4: int c (4)    // b后已对齐（0x4是4的倍数）
        +0x8: float d (4)  // c后已对齐
        note: "总大小: 12字节,填充位置：0x1"
    }

    %% pack(4) - int/float按4字节对齐
    class Packed4Example["#pragma pack(4) (4字节对齐)"] {
        +0x0: char a (1)
        +0x1: [填充3]      // a后填充3字节→保证：
                           // 1. short b从0x2开始（满足2对齐）
                           // 2. int c从0x4开始（满足4对齐）
        +0x2: short b (2)
        +0x4: int c (4)
        +0x8: float d (4)
        note: "总大小: 12字节\n填充位置：0x1-0x3"
    }

    %% pack(8) - 实际按4字节对齐（未超8字节）
    class Packed8Example["#pragma pack(8) (理论8对齐，实际同pack4)"] {
        +0x0: char a (1)
        +0x1: [填充3]      // 编译器优化为3字节（同pack4）
        +0x2: short b (2)
        +0x4: int c (4)
        +0x8: float d (4)
        note: "总大小: 12字节\n填充位置同 pack（4）"
    }
    
    %% 隐藏布局关系
    PackedExample --|> Packed2Example : <<对齐对比>>
    Packed4Example --|> Packed8Example : <<对齐对比>>

```

### 自定义对齐

除了自然对齐和编译器指令对齐，C 语言还允许通过特定属性或扩展手动设置变量或结构体的对齐方式。例如`GCC`编译器支持使用`_attribute_((aligned(n)))`来指定对齐字节数。

```c
typedef struct __attribute__((aligned(4))) {
    char   a;
    short  b;
    int    c;
    float  d;
} CustomAlignedExample;

CustomAlignedExample var;
```
强制 `var` 结构体按照 4 字节对齐，确保其在内存中的起始地址是 4 字节的倍数。

这个似乎看起来和`#pragma pack(4)`一样都是 4 字节对齐。它们有什么区别呢？

#### `__attribute__((aligned(2n)))`和`#pragma pack(2n)`的区别

|区别|`__attribute__((aligned(2n)))`|`#pragma pack(2n)`|
|-|-|-|
|对齐范围|主要影响结构体整体的对齐，不影响结构体内部成员的对齐方式。成员仍然按照各自的自然对齐方式。|强制结构体的每个成员按照4字节对齐，忽略成员的自然对齐需求。|
|编译器兼容|主要用于GCC编译器|更通用的指令，受到多种编译器的支持|


这两个结构体在内存布局如下图所示

```mermaid
graph TD
    subgraph CustomAlignedExample
        a1["char a: 0x00 - 0x01"]
        f1["fill: 0x01 - 0x02"]
        b1["short b: 0x02 - 0x04"]
        f2["fill: 0x04 - 0x05"]
        c1["int c: 0x04 - 0x08"]
        d1["float d: 0x08 - 0x0C"]
    end
    subgraph Packed4Example
        a2["char a: 0x00 - 0x01"]
        f3["fill: 0x01 - 0x04"]
        b2["short b: 0x04 - 0x06"]
        f4["fill: 0x06 - 0x08"]
        c2["int c: 0x08 - 0x0C"]
        d2["float d: 0x0C - 0x10"]
    end
```

## 结构体对齐

在 C 语言中，字节对齐主要就涉及到的就是结构体对齐。

> 结构体对齐主要是为了确保结构体中每个成员按照其自然对齐方式存储，以便提高`CPU`高效访问内存。



### 结构体大小

**结构体的总字节数是所有成员对齐后的总和，并且至少是最大成员对齐字节数的倍数**

### 结构体对齐的方式——4 字节对齐




```c

```


## 联合体对齐

## 数组对齐

