# 从源程序到二进制文件

## 从源程序到二进制文件

使用`ARM`交叉编译器将C源程序编译生成`ARM`格式的二进制可执行文件。

    # arm-linux-gnueabi-gcc -o a.out main.c sub.c
    # ./a.out

使用`readelf -h 可执行文件`命令可以获取可执行文件的头部信息。

    # readelf -h a.out
    ELF header:
    ...

主要包括可执行文件运行的平台，软件版本，程序入口地址，以及`program headers`、`section headers`等信息。通过文件的头部信息，可以知道在可执行文件中一共有多少个`section headers`。


一个可执行文件中有不同的段`section`组成：代码段、数据段、`BSS段`、只读数据段等，每个`section`用一个`section header`来描述。包括段名，段的类型，段的起始地址，段的偏移和段的大小等。这些`section header`集中在一起就是`section header table`（节头表）。

可以使用`readelf -S 可执行文件`来查看一个可执行文件的节头表。

    # readelf -S a.out  //大写的S
    There are 30 section headers, starting at offset 0x1cc0:
    Section Headers:
    ...


可执行文件的内部结构如下图所示：

![可执行文件的内部结构](https://img-blog.csdnimg.cn/img_convert/056aff4888af36c1ca2da00a47f48818.jpeg "可执行文件的内部结构")

[参考链接](https://blog.csdn.net/m0_57342549/article/details/132261745)

- 上面所说的`section header table`也是以一个`section`的形式存储在可执行文件中的；
- `ELF header`：用来描述文件类型，要运行的处理器平台、程序入口地址等信息；
- `.test`（代码段）：函数翻译成二进制指令放在代码段中；
- `.data`（数据段）：初始化的全局变量和静态局部变量放在数据段中；
- `.bss`：未初始化的全局变量和静态变量放在`BSS`段中，因为它们默认值都是0，没有必要单独开辟空间存储，为了节省存储空间，它们在可执行文件的`BSS`段中是不占用空间的。但是`BSS`段的大小，起始地址和各个变量的地址信息回分别保存在节头表`section header table`和符号表`.symtab`中，当程序运行时，加载器会根据这些信息在内存中紧挨着数据段的后面为`BSS`段开辟一片存储空间，为各个变量分配存储单元；
- `.rodata`：程序中定义的一些字符串，`printf`函数打印的字符串常量放置在该处；
- `.debug`：程序在编译时设置`debug`模式，可执行文件就会有一个`.debug section`，用来保存可执行文件中每一条二进制指令对应的源码位置信息。
- `.init`：C语言运行库的一些汇编代码，用来初始化C语言运行所依赖的环境，如内存堆栈的初始化。


不管是使用`gcc`或者`arm-linux-gcc`哪种编译程序，在编译器的安装路径的`bin`目录下都会看到各种编译工具，在编译的过程中分别调用。

|程序编译过程|说明|
|-|-|
|预处理器|将源文件`main.c`经过预处理变为`main.i`|
|编译器|将预处理后的`main.i`编译成汇编文件`main.s`|
|汇编器|将汇编文件`main.s`编译为目标文件`main.o`|
|链接器|将各个目标文件`main.o`、`sub.o`链接成可执行文件`a.out`|


目标文件一般分为3种：
1. 可重定位的目标文件：汇编器生成的目标文件，不可执行，需要链接器经过链接、重定位后才可以运行；
2. 可执行的目标文件：最终的`.out`文件
3. 可被共享的目标文件：一般以共享库的形式存在，在程序运行的时候需要动态加载到内存，跟着应用程序一起运行。


# 预处理过程

预处理命令包括：
- 头文件包括：`#include`
- 定义一个宏：`#define`
- 条件编译：`#if`、`#else`、`#endif`
- 编译控制：`#pragma`

通过`#pragma`预处理命令可以设定编译器的状态，指示编译器完成一些特定的动作。
- `#pragma pack[n]`：指示结构体和联合成员的对齐方式；
- `#pragma message("string")`：在编译信息输出窗口打印自己的文本信息；
- `#pragma warning`：有选择的改变编译器的警告信息行为；
- `#pragma once`：在头文件中添加这条指令，防止头文件被多次编译。

> 预处理过程：在编译源程序之前，先处理源文件中的各种预处理命令，编译器是不认识预处理命令的，在编译之前如果不先将这些预处理命令处理掉，编译器就会报错。

预处理过程包括以下步骤：
- 头文件展开：将`#include`包含的头文件内容展开到当前位置；
- 宏展开：展开所有的宏定义，并删除`#define`；
- 条件编译：根据宏定义条件，选择要参与编译的分支代码，其余的分支丢弃；
- 删除注释；
- 添加行号和文件名标识：编译过程中根据需要可以显示这些信息；
- 保留`#pragma`命令：该命令会在程序编译的时候指示编译器执行一些特定行为。


可以输入以下命令对C文件只进行预处理操作，不编译，将输出的的信息重定向到`main.i`文件

    # arm-linux-gnueabi-gcc -E main.c > main.i  --预处理，重定向到main.i
    # cat main.i
    ...
    ...

    # arm-linux-gnueabi-gcc main.i              --继续编译

# 程序的编译

预处理后，编译分成两步：
1. 编译器调用一系列的解析工具，分析C代码，将C源文件编译成汇编文件；
2. 通过汇编器将汇编文件汇编成可重定位的目标文件。

## 从C文件到汇编文件

从C语言到汇编文件的转换，其实就是将C文件中的程序代码块，函数转换为汇编程序中的代码段，将C程序中的全局变量、静态变量、常量转换成汇编程序中的数据段、只读数据段。

编译过程分为以下6步：
1. 词法解析
2. 语法解析
3. 语义解析
4. 中间代码生成
5. 汇编代码生成
6. 目标代码生成

### 词法分析
通过词法扫描器从左到右，一个字符一个字符读入源程序，将源程序分解成一系列不能再分解的记号单元——`token`

常见的`token`如下：
- C语言中各种关键字：`int`，`float`，`for`等
- 用户定义的各种标识符：函数名，变量名，标号等
- 字面量：数字、字符串等
- 运算符：C语言标准定义的40多个运算符
- 分隔符：程序结束符分号`;`，`for`循环中的逗号`,`等

如果程序中输入了中文的符号，编译出错就发生在这个阶段

### 语法分析

对上一阶段产生的`token`序列进行解析，看能否构成语法上正确的语法短语。语法短语用语法书表示，是一种树型结构，不再是线性序列。如果不能构建语法上正确的语句或者表达式，就会报语法错误`syntax error`。

比如程序中`for`循环少了一个分号，报的错误就属于语法错误。

### 语义分析

> 语义分析主要对语法分析输出的各种表达式、语句进行检查，看看有没有错误。

如果传递给函数的实参与函数声明的形参类型不匹配，或者使用了一个未声明的变量，或者除数为0了，`break`在循环语句或者`switch`语句之外出现了，或者在循环语句之外发现了`continue`语句。一般都会报语义上的错误或者警告。

### 生成中间代码

在语法分析阶段输出的表达式或者程序语句，还是以语法树的形式存储，需转换成中间代码。中间代码是一种临时代码，常见的有三地址代码，`P-代码`。

中间代码一般是与平台无关的。然后根据对应的平台指令集将中间代码翻译成汇编程序。

## 汇编过程

> 汇编过程使用汇编器将前一阶段生成的汇编文件翻译成目标文件。

汇编器的主要工作就是将汇编代码翻译成对应的二进制指令，同时生成一些必要的信息，以`section`的形式组装到目标文件中，后面的链接过程会用到这些信息。

汇编过程包括：
1. 词法分析
2. 语法分析
3. 指令生成

通过编译生成的可重定位的目标文件，都是以零地址为链接起始地址进行链接的。在每个可重定位的目标文件中，函数或者变量的地址其实就是在文件中相对于零地址的片偏移。每个目标文件都是这样。

在后面的链接过程中，将各个目标文件链接在一起，各个目标文件参考的起始地址就发生了变化，那么这个目标文件的函数或变量的地址也要随之更新，否则就无法引用函数和变量。

> 重定位：链接器在将各个目标文件组装在一起后，需要重新修改各个目标文件中变量或函数的地址，这个过程称为重定位。

把需要重定位的符号收集起来，生成一个`重定位表`，以`section`的形式保存到每个可重定位的目标文件中就可以。

此外，一个文件中所有符号，无论是函数名还是变量名，无论是否需要重定位，都会收集起来，生成一个`符号表`，以`section`的形式添加到每一个可重定位目标文件中。

## 符号表和重定位表

符号表和重定位表为链接过程提供各种必要的信息。在汇编阶段，汇编器会分析汇编语言中各个`section`的信息，收集各种符号，生成`符号表`，将各个符号在`section`内的偏移地址也填充到`符号表`中。

可以使用`readelf -s 目标文件`的方式查看目标文件的符号表。

    # readelf -s sub.o
    ...

在编译的过程中，`符号表`主要用来保存源程序中各种符号的信息，包括符号的地址、类型、占用空间大小等。`符号表`的本质是一个结构体数组，在`ARM`平台下，定义在Linux内核源码的`/arch/arm/include/asm/elf.h`文件中。

    typedef struct elf32_sym
    {
        Elf32_Word st_name;         //符号名，字符串表中的索引
        Elf32_Addr st_value;        //符号对应的值
        Elf32_Word st_size;         //符号大小，如int类型数据符号=4
        unsigned char st_info;      //符号类型和绑定信息
        unsigned char st_other;     
        Elf32_Half st_shndx;        //符号所在的段
    }Elf32_Sym;

符号表的每一个符号，都有符号值和类型。符号值的本质是一个地址，可以是绝对地址，一般出现在可执行目标文件中，也可以是相对地址，出现在可重定位目标文件中。

符号的类型主要有：
- `OBJECT`：对象类型，一般用来表示程序中的变量；
- `FUNC`：关联的是函数名或其他可引用可执行代码；
- `FILE`：该符号关联的是当前目标文件的名称；
- `SECTION`：表明该符号关联的是一个`section`，主要用来重定位；
- `COMMON`：表明该符号是一个公用块数据对象，是一个全局弱符号，在当前文件中未分配空间；
- `TLS`：表明该符号对应的变量存储在线程局部存储中；
- `NOTYPE`：未指定类型，或者目前还不知道该符号的类型。

编译器在给每个目标文件生成`符号表`的过程中，如果在当前文件中没有找到符号的定义，也会将这些符号收集起来并保存到一个单独的符号表中，以待后续填充，这个符号表就是`重定位符号表`。

在程序中，引用其他文件的函数或者全局变量，编译器不会报错，编译器会认为引用的这个全局变量或者函数在其他文件、库中定义，在编译阶段暂时不会报错。后面的链接过程，链接器会尝试在其他文件或库中查找引用的这个符号的定义，找不到才会报错。该错误类型属于链接错误。

可以通过`readelf -s 目标文件`查看未定义的符号`NOTYPE`，需要后续填充。

通过`readelf -S 目标文件`查看目标文件的`section head table`信息。通过`readelf -r 目标文件`查看目标文件的`重定位表`。

    # readelf -S main.o
    There are 13 section headers,starting at offset 0x330:
    ...
    [ 2] .rel.text   REL     00000000  000298  000030 
    ...

    # readelf -r main.o
    Relocation section '.rel.text' at offset 0x298 contains 6 entries:
    Offset    Info    Type       Sym.Value     Sym   Name
    ...
    # readelf -r sub.o
    There are no relocation in this file.

在`重定位表.rel.text`中，需要重定位的符号包括`add`、`sub`、和库函数`printf`。这些符号所关联的地址，在后面的链接过程中经过重定位，会更新为新的实际地址。

# 链接过程

链接主要分成3个过程：
- 分段组装
- 符号决议
- 重定位


## 分段组装

链接器将编译器生成各个可重定位目标文件重新分解组装：将各个目标文件的代码段放在一起，作为最终生成的可执行文件的代码段；将各个目标文件的数据段放在一起，作为可执行文件的数据段。其他的`section`按照同样的方法进行组装。生成一个可执行文件的雏形。


链接器会在可执行文件中创建一个全局的符号表，收集各个目标文件符号表中的符号，然后将其统一放到全局符号表中。一个可执行文件中所有的符号都有了自己的地址，并保存在全局符号表中，但是此时全局符号表中的地址都是原来在各个目标文件中的地址，即相对于零地址的偏移。


程序在链接程序时需要指定一个链接起始地址，链接起始地址一般也就是程序要加载到内存中的地址。链接的先后组装顺序也是需要考虑的。链接地址和各个段的组装顺序通过`链接脚本`来指定。


`链接脚本`中规定了各个段的组装顺序，起始地址，位置对齐等信息，同时对输出的可执行文件格式、运行平台、入口地址等信息做了详细描述。链接器就是根据链接脚本来组装可执行文件的，最终将这些信息以`section`的形式保存到可执行文件的`ELF Header`中。

一个简单的链接脚本：

    OUTPUT_FORMAT("elf32-littlearm")    ;输出ELF文件格式
    OUTPUT_ARCH("arm")                  ;输出可执行文件的运行平台为arm
    ENTRY(_start)                       ;程序入口地址
    SECTIONS
    {
        .=0x60000000                    ;代码段的起始地址       
        .text:{*{.text}}                ;代码段描述：所有.o文件中的.text
        .=0x60200000                    ;数据段的起始地址
        .data:{*{.data}}                ;数据段描述：所有.o文件中的.data
        .bss:{*{.bss}}                  ;BSS段描述
    }

程序运行时，加载器会首先解析可执行文件中的`ELF Header`头部信息，验证程序的运行平台和加载地址信息，然后将可执行文件加载到内存中对应的地址，程序就可以正常运行了。

在Windows或Linux环境下编译程序，一般会使用编译器提供的默认链接脚本。

## 符号决议

### 强、弱符号

链接器在链接时，当在多个文件中定义了同名的全局变量名或者函数名时，就会发生符号冲突。链接器针对这种情况，会有专门的符号决议规则来处理冲突：
1. 一山不容二虎
2. 强弱可以共存
3. 体积大者胜出

具体说明：

- 函数名、初始化的全局变量为`强符号`；
- 未初始化的全局变量为`弱符号`；
- 在一个多文件工程中，`强符号`不允许多次定义，否则发生重定义错误；
- `强符号`和`弱符号`可以在一个项目中共存，共存时，`强符号`会覆盖掉`弱符号`，链接器会选择`强符号`作为可执行文件的最终符号；
- 链接器允许一个项目中多个`弱符号`共存，在程序编译期间，未初始化的全局变量并没有被直接放置在`BSS`段中，而是将这些弱符号放到一个叫做`COMMON`的临时块中，在符号表中使用一个未定义的`COMMON`来标记，在目标文件中也没有给它们分配存储空间。链接器会选择占用空间最大的一个，作为可执行文件的最终符号，此时弱符号的大小已经确定，并被直接放到了可执行文件的`BSS`段中。

`强符号`可以显示转化为`弱符号`，在`GNU C`编译器中，提供了`_attribute_`关键字来声明符号的属性。

    _attribute_((weak)) int n = 100;
    _attribute_((weak)) void fun();


### 强、弱引用

函数名和变量名这些符号的本质都是地址。通过符号去调用一个函数或者变量，通常称之为引用。强符号对应强引用，弱符号对应弱引用。

若对一个符号的引用为强引用，链接时找不到其定义，链接器将会报未定义错误；若对一个符号的引用为若引用，链接时找不到其定义，则链接器不会报错，不会影响最终可执行文件的生成。可执行文件在运行时如果没有找到该符号的定义才会报错。

利用链接器对弱引用的处理规则，在引用一个符号之前可以先判断该符号是否存在（定义）。

这样做的好处在于，当引用一个未定义的弱符号时，在链接阶段不会报错，在运行阶段通过判断运行，也可以避免运行错误。例如，当我们实现一个视频编码模块时，封装成库的形式给开发者调用，可以将库中某些API函数声明为弱符号，这样做的好处在于：
1. 当对库中某些API函数的实现不是很满意时，或者存在bug时，有更好的实现时，可以自定义与库函数同名的函数，直接调用它们而不会发生冲突。
2. 在库的实现过程中，可以将某些扩展功能模块中还未完成的一些API定义成为弱引用。应用程序在调用这些`API`之前，要先判断该函数是否实现，然后才调用运行。这样在未来发布新版本时，无论这些接口是否实现，或者已经删除，都不会影响应用程序的正常链接和运行。

## 重定位

经过符号决议之后，虽然符号表中的每一个符号都确认下来了，但是其地址还是基于零地址的偏移。但是经过分解组装之后，各个段的起始地址都发生了变化。

链接器在链接程序时一般会基于某个链接地址进行链接，更新各个目标文件中的函数或者符号的地址。修改全局符号表中这些符号的值，并将它们的地址更新到符号表中。修改过后，如果想要通过符号调用一个函数或者一个变量时，就可以找到它们在内存中的真实地址。


链接器根据每个目标文件中的`重定位表`，专门记录各个文件中需要重定位的符号，重定位的核心工作就是修正指令中的符号地址，是链接过程中的最后一步、最重要的一步。


无论是代码段还是数据段，只要这个段中有需要重定位的符号，编译器都会生成一个`重定位表`与之对应：`.rel.text`和`.rel.data`。这些`重定位表`记录需要重定位的各种符号，并以`section`的形式保存在各个目标文件中。可以通过`readelf -r 目标文件`或`objdump -r 目标文件`命令来查看一个目标文件的`重定位表`信息。


`重定位表`中还有一个比较重要的信息，需要重定位的符号在指令代码中的偏移地址`offset`。链接器修正指令代码中的各个符号的值时要根据这个地址信息，才可以在二进制代码中找到它们。

# 程序的安装

## 程序安装的本质

> 软件安装的过程其实就是将一个可执行文件安装到`ROM`的过程。

软件安装包中，将可执行文件，程序运行时需要的动态共享库、安装使用文档等打包压缩，生成可运行的自解压安装包格式。


使用安装包安装软件时，就是将包中的可执行文件解压出来，然后将可执行文件和动态共享库复制到指定的安装目录，并把这些安装信息高速操作系统。当用户需要运行这个软件时，操作系统就会从安装目录找到这个可执行文件，并把它加载到内存中执行。

在Linux环境下，一般将可执行文件直接复制到系统的官方路径`/bin`、`/sbin`、`/usr/bin`下，程序运行时直接从这些系统默认的路径下去查找可执行文件，将其加载到内存运行。

## 在Linux下制作软件安装包

Linux操作系统一般分为两派：`Redhat`系和`Debian`系。`Redhat`系使用`RPM`包管理机制，而`Debian`系，像`Debian`和`Ubuntu`等操作系统则使用`deb`包管理机制。

在Linux环境下安装软件其实就是将可执行文件复制到环境变量`PATH`对应的官方路径下面，常用的路径有`/bin`、`/sbin`、`/usr/bin`等。当在`shell`终端输入命令时，`shell`就会到这些默认的路径下去找与该命令相对应的二进制文件，并加载到内存执行。


在制作`deb`包时，除了可执行文件，还需要有一些控制信息来描述安装包，如软件的版本，作者，安装包要安装的路径等，这些信息放在一个叫做`control`的文件中。

制作软件安装包的过程：
1. 创建一个`helloworld`同名目录，并建立子目录`DEBIAN`和`usr/local/bin`；
2. `DEBIAN`目录下的`control`文件用来记录`helloworld`安装包的安装信息，`usr/local/bin`存放可执行文件`helloworld`；
3. `usr/local/bin`表示`deb`包的默认安装路径，使用`dpkg`命令来制作安装包。
`dpkg -b helloworld/ helloworld_1.0_i386.deb`
4. 在`helloworld`同级目录下，生成一个`helloworld_1.0_i386.deb`的安装包；
5. 使用`dpkg`命令安装这个`deb`包，`# dpkg -i helloworld_1.0_i386.deb`；
6. `helloworld`安装成功后，在系统的`/usr/local/bin`下就会看到安装成功的`helloworld`z执行文件。安装成功后，在`shell`终端的任何目录下，直接输入`helloworld`命令都可以直接运行。
7. 也可以通过`dpkg`命令卸载`helloworld`

如下

    # dpkg -P helloworld        //卸载helloworld程序及配置文件
    # dpkg -r helloworld        //卸载helloworld程序


## 使用apt-get在线安装软件

`Ubuntu`操作系统采用一个软件仓库管理`deb`包，第三方开发者发布的软件和工具首先要通过官方验证，然后把这些包放到一个官方网站服务器上，提供给用户下载使用，类似于`App Store`。

当用户使用`apt-get`命令安装软件时，只能到这个服务器上下载。考虑到全球各个地方的网络状况差异，官方网站一般会在全球各地配置多个镜像服务器。用户可以根据自己的网络状况，到网速最快的服务器上去下载和安装`deb`包。这些服务器也被称为软件源。这些源的地址保存在`/etc/apt/source.list`文件中。格式如下

    deb http://us.archive.ubuntu.com/ubuntu/ xenial universe

当用户使用`apt-get install`安装软件时，`apt-get`工具就根据这个`source.list`文件中的服务器地址去下载对应的软件包。


国内的一些高校和互联网公司其实也提供了镜像服务器提供下载，如阿里云软件源，中科大软件源。一般可以搜到很多服务器地址，选择其中一个添加到`/etc/apt/source.list`文件中。之后就会在这个服务器上下载，会很快。

修改好`/etc/pt/source.list`之后，需要使用`# apt-get update`更新一下源。这个命令的作用是访问`/etc/pt/source.list`文件中的每一个服务器，读取可以支持下载的软件列表，并保存到本地计算机中（`/var/lib/apt/lists`），如果要安装不在列表中的软件时，会报错。

    qintian@Ubuntu:/var/lib/apt/lists# apt update
    ...                     //软件更新提示信息
    qintian@Ubuntu:/var/lib/apt/lists# apt list --upgradable
    ...                     //需要更新的软件包信息

使用`# apt-get upgrade`命令更新这些已经安装的软件。这个命令会将本地已经安装的软件与刚刚使用`# apt-get update`命令下载到本地的软件列表进行对比，如果发现版本不一致，就会重新安装最新的版本。

使用`apt-get`安装软件的另外一个好处是可以自动处理依赖关系。在`/var/lib/dpkg/available`文件中，有软件包的各种详细信息，软件版本，软件依赖的包等。

# 程序的运行

> 程序的运行过程，其实就是处理器根据`PC`寄存器中的地址，从内存中不断取指令、翻译指令和执行指令的过程。

程序的运行分成两种情况，一种是在有操作系统的环境下执行一个应用程序；另一种是在无操作系统的环境下执行一个裸机程序。


在Linux环境下，可执行文件是`ELF`格式，而在裸机环境下执行的程序一般是`BIN/HEX`格式。`BIN/HEX`文件是纯指令文件，没有其他辅助信息，而`ELF`文件除了基本的代码段、数据段，还有文件头，符号表等用来辅助程序运行的信息。


## 在操作系统环境下的程序运行

当执行一个应用程序的时候，首先会运行一个叫做`加载器`的程序。`加载器`会根据软件的安装路径信息，将可执行文件从`ROM`中加载到内存，然后进行一些与初始化，动态库重定位相关的操作，最后再跳转到程序的入口运行。

在不同的操作系统下，可以由不同的程序充当`加载器`的角色，如在Linux命令行模式下，运行一个应用程序，类似于`sh`，`bash`这样的`shell`终端程序就充当加载器的角色：它们将程序加载到内存，封装成进程，参与操作系统调度和运行。

`加载器`在加载程序之前会首先根据可执行文件的文件头的信息做一些判断，如果发现程序运行平台和当前环境不符，就会报错处理。


可执行文件有一个`program header table`的`section`，叫做段头表，记录如何将可执行文件加载到内存的相关信息，包括可执行文件中要加载到内存中的段，入口地址等信息。可重定位目标文件因为不可执行，所以`program header table`是可选的。



在Linux环境下运行的程序一般都会被封装成进程，参与操作系统的同一调度和运行。在`shell`环境下运行一个程序，`shell`终端程序一般会`fork`一个子进程，创建一个独立的虚拟进程地址空间，接着调用`execve`函数将要运行的程序加载到进程空间：通过可执行文件的文件头，找到程序的入口地址，建立进程虚拟空间与可执行文件的映射关系，将`PC`指针设置为可执行文件的入口地址，即可启动运行。

|可执行文件和进程的区别|说明|
|-|-|
|可执行文件|<li>程序是一个静态概念，就是编译好的指令和数据集合的一个文件|
|进程|<li>进程是一个动态概念，它是程序运行时的一个过程；<li>进程只能使用操作系统给它分配的空间，32位地址空间，进程只能使用3GB，剩余的供给操作系统使用；<li>如果进程访问未经允许访问的空间，操作系统会捕获这些访问，并把这些行为当作非法操作，结束进程|


一般情况下，程序的入口地址：

    程序入口地址=编译时的链接地址+一定偏移（程序头会占用一部分空间）

不同的编译器有不同的链接起始地址。一个可执行文件加载到内存中执行，它在内存中的地址空间分布如下：

![进程的地址空间](https://img-blog.csdnimg.cn/2020060700313756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FueWVnb25nanVlempk,size_16,color_FFFFFF,t_70)

[参考链接](https://blog.csdn.net/anyegongjuezjd/article/details/105032023)

进程虚拟地址空间并没有全部分配给进程使用。Linux将进程地址空间划分成两个部分：位于高地址部分的`内核地址空间`和位于低地址部分的`用户地址空间`。

程序链接时的链接地址是虚拟地址。虽然每个进程的地址空间都是一样的，但是每个进程都有自己的`页表`，页表里的每一个条目叫做`页表项`，`页表项`里存储的是虚拟地址和物理地址之间的映射关系，相同的虚拟地址经过`MMU`（内存管理单元）硬件转换后，会分别映射到物理内存的不同区域，彼此相互隔离和独立，一点也不会起冲突。

![虚拟内存到物理内存的转化](https://img-blog.csdn.net/20180830111258836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x2eWliaW44OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

[参考链接](https://blog.csdn.net/hjwdz2015/article/details/108562639)

在Linux中，对于每一个在运行的进程，Linux内核都会使用一个`task_struct`结构体来表示，多个结构体指针构成链表，操作系统基于该链表就可以对这些进程进行管理、调度和运行。


## 在裸机环境下的程序运行

在一个嵌入式Linux系统中，Linux内核镜像的运行其实就是裸机环境下的程序运行。Linux内核镜像一般会借助`U-boot`这个加载工具将其从`Flash`存储分区加载到内存中运行，`U-boot`在Linux启动过程中扮演了`加载器`的角色。

`U-boot`自身也和Linux内核镜像一样，存储在`NAND/NOR`分区上。在`U-boot`启动过程中，要将自身代码从存储分区复制到内存中，还要完成自身代码的重定位。这一过程称为“自举”。

## 程序入口main()函数分析

程序的入口是`main()`函数，但是在`main()`函数运行之前，也会有其他的代码在运行，主要完成一些初始化的工作：
- 初始化堆栈指针，通过运行一段汇编代码来初始化堆栈环境
- 初始化`data`段的内容，初始化`static`静态变量和`global`全局变量，并给`BSS`段的变量赋初值：未初始化的全局变量中，`int`赋值为0，布尔型变量赋值为`FALSE`，指针型的变量的初始化为`NULL`
- 完成初始化环境之后，还会将用户传入的参数传递给`main()`函数，最后再跳入`main()`函数运行。

这部分初始化代码是在程序编译阶段，由编译器自动添加到可执行文件中，属于C运行库中的代码，编译器
厂商在开发编译器是，除了实现C标准中规定的函数，还会实现这部分初始化代码，完成进入`main()`函数之前的一系列初始化操作。

1. C语言运行的基本堆栈环境、进程环境
2. 动态库的加载、释放、初始化、清理等工作
3. 向`main()`函数传递参数`agrc`、`agrv`，调用`main()`函数执行
4. 在`main()`函数退出后，调用`exit()`函数，结束进程的运行。

在`ARM`交叉编译器安装路径的`lib`目录下，有一个`ctrl.o`文件，就是由汇编初始化代码编译生成的
，在链接过程中，`链接器`将这个目标文件和项目中目标文件组装在一起，生成最终的可执行文件。可以使用`objdump -D ctrl.o`反汇编这个目标文件。


在裸机环境下，系统上电之后，需要初始化时钟，内存，然后设置堆栈指针，在普通的操作系统环境下，这些工作已经准备好，直接跳到第一个C语言入口函数：`_libc_start_main`，这个函数的大致历程如下：
1. 设置程序运行的进程环境，加载共享库，解析用户输入的参数，将参数传递给`main()`函数
2. 调用`main()`函数运行，再调用`exit()`函数结束整个进程。

`main()`函数只是程序员约定好的默认入口，并不是一成不变，程序员可以自定义程序入口。通过下面的命令就可以完成：

    # arm-linux-gnueabi-gcc -nostartfiles -e <入口函数> xx.c
    # arm-linux-gnueabi-gcc -nostartfiles -e mymain test.c

参数`-nostartfiles`表示不链接`ctrl.o`，通过显示指定函数入口编译生成的可执行程序，也可以正常运行。但是需要注意的是，函数退出时不能用`return`，而要使用`exit`，否则会报段错误，因为可执行文件没有链接`ctrl.o`，无法再处理`mymain()`函数退出后的处理工作。

## BSS段的小秘密

`BSS`段在可执行文件中是不占用存储空间的，但是当程序加载到内存中时，加载器会在内存中给`BSS`段开辟一段存储空间。

`加载器`会根据在`section header table`中记录的`BSS`段的大小以及符号表中每个变量的地址和大小，在数据段后面分配指定大小的内存空间并清零，根据符号表中各个变量的地址，在这片内存中给各个未初始化的全局变量、静态变量分配存储空间。

编译器对于数据段和`BSS`段的处理流程是一样的，唯一的差异在于：在可执行文件内不给`BSS`段分配存储空间，在程序运行内存时再分配存储空间和地址。

# 链接静态库

库分为动态库和静态库。

> 在项目中引用了库函数，在编译时，链接器会将引用的函数代码或变量，链接到可执行文件中，和可执行程序组装在一起，这种库被称为静态库，即在编译阶段链接的库。

> 动态库在编译阶段不参与链接，不会和可执行文件组装在一起，而是在程序运行时，才被加载到内存参与链接。

## 静态库的制作

将`test.c`文件打包成一个库，在`main.c`中调用该库的`add`函数

    # gcc -c test.c                 //生成目标文件
    # ar rcs libtest.a test.o       //将test.o打包成静态库
    # gcc main.c -L -ltest          //指定要链接的库的名字和路径

在编译`main.c`时，通过参数指定要链接的静态库及其所在路径就可以了。编译参数大写的`L`表示要链接的库的路径，小写的`l`表示要链接的库的名字。链接时库的名字要去掉前后缀，如`libtest.a`，链接时要指定的库名字为`test`。

`ar`命令制作静态库的部分参数：

- `-c`：禁止在创建库时产生的正常消息；
- `-r`：如果指定的文件已经在库中存在，则替换它
- `-s`：无论库是否更新都强制重新生成新的符号表
- `-d`：从库中删除指定的文件
- `-o`：对压缩文档成员进行排序
- `-q`：向库中追加指定文件
- `-t`：打印库中的目标文件
- `-x`：解压库中的目标文件

如果在一个源文件中定义了100个函数，但是只使用到了其中的1个，那么链接器在链接的时候也会将100个函数的代码指令全部组装到可执行文件中，这会让最终生成的可执行文件体积增大。

解决方法就是，将每个函数都单独使用一个源文件实现，然后将多个目标文件进行打包。如下：

    # gcc -c add.c sub.c mul.c div.c
    # ar rcs libtest.a add.o sub.o mul.o div.o
    # gcc main.c -L -ltest

C的标准库就是这样的逻辑，每一个库函数都是单独使用一个同名的源文件实现的，`printf()`函数单独定义在`printf.c`文件中。链接器只是将`printf()`函数的目标文件链接到你的可执行文件中。


在一个多任务环境中，可能会有很多进程同时都会使用到`prinf()`指令代码，在内存中重复，浪费内存资源。这个时候就需要使用到动态链接。


# 动态链接

静态链接的缺点：
1. 生成的可执行文件的体积较大；
2. 当多个程序引用相同的公共代码时，这些公共代码会多次加载到内存，浪费内存资源。

动态链接的优化：对一些公用的代码，如库，在链接期间暂不链接，在程序运行的时候再进行链接；


这些程序运行时才参与链接的库被称为`动态链接库`，程序运行时，除了可执行文件，动态库也需要跟着一起被加载到内存中，参与链接和重定位过程，否则程序就会报未定义错误，无法运行。

动态链接的好处是节约内存，加载到内存的动态库可以被多个运行的程序共享。Windows环境下解压一个软件安装包，里面会有很多`.dll`文件，这些就是动态链接库，Linux环境下的动态库后缀名为`.so`文件。


一个软件采用动态链接，版本升级时，无需改变主程序的业务逻辑或框架，只需要更新对应的`.dll`或`.so`文件就可以。

制作动态库：

    # gcc -fPIC -shared add.c sub.c mul.c div.c -o libtest.so
    # gcc main.c libtest.so
    # ./a.out
    cannot open shared object file: No such file or directory
    # cp libtest.so /usr/lib
    # ./a.out 
    ...

在运行`a.out`之前，`libtest.so`这个动态链接库需要放在`/lib`、`/usr/lib`等系统默认的库路径下，否则`a.out`就会动态链接失败，无法正常运行。

在Linux环境下，运行一个程序时，首先会给程序`fork`一个子进程，接着`动态链接器`被加载到内存，操作系统将控制权交给动态链接器，让动态链接器完成动态库的加载和重定位操作，最后跳转到要运行的程序。

`动态链接器`在C标准库中实现，主要完成程序运行前的动态链接工作。在可执行文件的`.interp`段中存放有动态链接器的加载路径，可以通过`objdump`查看

    # arm-linux-gnueabi-objdump -j .interp -s a.out
    a.out       file format elf32-littlearm
    Contents of section .interp:
    10154 2f6c6962 2f6c642d 6c696e75 782e736f /lib/ld-linux.so
    10164 2e3300

动态链接器本身就是一个动态库，即`/lib/ld-linux.so`文件。`动态链接器`被加载到内存后，会首先给自己重定位，然后才能运行，即“自举”。

动态链接器解析可执行文件中未确定的符号及需要链接的动态库信息，将对应的动态库加载到内存，并进行重定位操作。与静态库的重定位过程一样，只不过推迟到了程序运行阶段。


![进程虚拟空间的动态链接库](https://static-public-imhuwq.oss-cn-shenzhen.aliyuncs.com/writing/virtual-memory/linux-memory-area.png)


[参考链接](https://imhuwq.com/2019/03/25/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%93%E6%9E%84/)


动态链接需要考虑的一个重要问题就是加载地址。静态库和可执行文件一起被加载到虚拟内存空间，这个地址是固定的，一般就是链接地址。动态链接库加载到内存的地址是随机的，因为不同的可执行文件的大小不同，加载到内存后进程剩余的地址空间也不相同，动态链接库的地址需要根据进程地址空间的实际空闲情况随机分配。


> 装载时重定位：一个可执行文件对动态链接库的符号引用，要等动态链接库加载到内存后地址才能确定，然后对可执行文件中的这些符号地址修改即可。


## 与地址无关的代码

装载时重定位有一个弊端就是，对于每个进程来说，动态库如果被加载到了内存的不同地址，也只能被进程自身共享，无法在多个进程之间共享，无法节约内存。

一个好的解决方法在于将动态库设计成与地址无关的代码。思路就是将指令中需要修改的部分，如绝对地址符号的引用分离出来，剩余的部分就和地址无关了，放到哪里都可以执行，而且可以被多个进程共享。


与地址无关的代码实现比较简单，在编译代码的时候加上`-fPIC`。加上了`-fPIC`参数生成的指令，实现了代码与地址无关，放到哪里都可以执行。

    # arm-linux-gnueabi-gcc -fPIC -c main.c

实现与代码无关，在模块内部，对函数和全局变量的引用要避免使用绝对地址，一般可以使用相对跳转代替。在`ARM`平台中，采用相对寻址来实现。通过这种相对须知的符号引用，可以做到代码与地址无关：把这段代码放在内存中的任何位置，都无须重定位，直接运行即可。

## 全局偏移表

除去与地址无关的代码，还有一些绝对地址符号（如函数名）将不可避免的被多次调用，需要重定位。

解决这个问题的核心思想：

> 每个应用程序将引用的动态库（绝对地址）符号收集起来，保存到一个表中，这个表用来记录各个引用符号的地址。当程序在运行过程中需要引用这些符号时，可以通过这个表查询各个符号的地址。这个表称为`全局偏移表`（`GOT`）。

在一个可执行文件中，其引用的动态库中的绝对地址符号（如函数名）会被分离出来，单独保存到`GOT`表中，`GOT`表以`section`的形式保存在可执行文件中，这个表的地址在编译阶段就已经确定了。当程序运行需要引用动态库中的函数时，会将动态库加载到内存，根据动态库被加载到内存的具体地址，更新`GOT`表中各个符号（函数）的地址。等下次该符号被引用时，程序就可以直接跳到`GOT`表中查询该符号的地址，如果找到要调用的函数在内存中的实际地址，就可以直接跳过去执行。

因为`GOT`表在可执行文件中的位置是固定不变的，所以程序中访问`GOT`表的指令也是固定不变的，唯一变化的是：动态库加载到内存后，库中各个函数的位置确定，在`GOT`表中实时更新各个符号在内存中的真实地址就可以了。

这样的好处在于：在内存中只需要加载一份动态库，当不同的程序运行时，只要修改各自的`GOT`表，它们引用的符号都可以指向同一份动态库，就可以达到不同程序共享一个动态库的目的。

## 延迟绑定

动态库通过使用与地址无关的技术，加载到任何内存任意地址都可以运行，这一技术在`ARM`中使用了相对寻址技术。这种寻址的访问效率比较低。假设一个程序中有几百个地方使用动态链接，如果把所有的动态库一次性全部加载到内存中并一一进行重定位，会耗费很多时间。而且程序中的`if-else`分支，不是所有的动态链接都会使用到，加载到内存的动态库可能没有被调用，这样会白白浪费内存空间。


> 解决方法：延迟绑定，程序运行的时候，并不着急把所有的动态库都加载到内存中并进行重定位，当动态库中的函数第一次被调用到时，才会把用到的动态库加载到内存中并进行重定位。提高程序运行速度，节省内存。

指令代码中每一个使用动态链接的符号`<x@plt>`，都被保存在`过程链接表PLT`中。过程链接其实就是一个跳转指令，它无法单独工作，要和`GOT`表相关联，协同工作。

![延迟绑定](https://img-blog.csdnimg.cn/20200802205858237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FueWVnb25nanVlempk,size_16,color_FFFFFF,t_70)

[参考链接](https://blog.csdn.net/anyegongjuezjd/article/details/107751087)

`PLT`本质是一个数组，每一个在程序中被引用的动态链接库函数，都在数组中对应其中一项，跳转到`GOT`表中的对应项。

`PLT`有两个特殊项，`PLT[0]`会关联到`动态链接器`的入口地址，`PLT[1]`会关联到初始化函数：`_libc_start_main()`，该函数会初始化C语言运行的基本环境：调用`main()`函数，等`main()`函数运行结束时，根据返回值做响应的处理，同时还负责`main()`函数运行结束后的清理工作。


C标准库其实就是以动态共享库的封装形式保存在Linux系统中的。不同的应用程序都会调用到`printf()`函数，当他们在内存中运行时，只需要加载一份`printf()`函数代码到内存就可以了。

## 共享库

程序在安装时，可执行文件会复制到Linux系统的默认路径下，如`/bin`、`/sbin`、`/usr/bin`、`/usr/sbin`、`/usr/local/bin`等，这些路径有环境变量`PATH`管理和维护。可执行文件依赖的共享库一般要放到库的默认路径下，如`/lib`、`/usr/lib`等。

当程序运行时，动态链接器首先被加载到内存运行，动态链接器会分析可执行文件，从可执行文件的`.dynamic`段中查询程序运行所需要依赖的动态共享库，然后到库的默认路径下查找这些共享库，加载到内存中并进行动态链接。


动态链接器在查找共享库的过程中，除了用到系统默认的路径（`/lib、/usr/lib`）下查找，也可以到用户指定的路径下去查找，在`/etc/ld.so.conf`文件中添加自己的共享库路径。为了减少每次查找文件的时间消耗，`/etc/ld.so.conf`修改后，可以使用`ldconfig`命令生成一个缓存`/etc/ld.so.chche`以提高查找效率，每当修改共享库的路径时，使用`ldconfig`更新一下缓存就可以了。


系统中所有的程序在运行时，都会按照上面的这种方式查找共享库。也可以使用环境变量`LD_LIBRARY_PATH`临时改变共享库的查找路径，而不会影响系统中的其他应用程序。可以将多个共享库的路径添加到这个环境变量中，各个路径使用`:`隔开。

    # export LD_LIBRARY_PATH = /home/wit/lib:/usr/test/lib

# 插件的工作原理

> 插件的本质就是共享动态库

Linux系统提供了专门的系统调用接口，支持显示加载和引用动态链接库，常用的`API`如下：

1. 加载动态链接库

        void *dlopen(const char *filename, int flag);       
        void *Handle = dlopen("./libtest.so", RTLD_LAZY);   
    `dlopen()`函数的第一个参数是要打开的动态库，第二个是打开的标志位，返回一个操作句柄，通过这个句柄即可操作显示加载到内存中的动态库。

2. 获取动态对象的地址

        void *dlsym(void *handle, char *symbol);
        void (*funcp)(int, int);
        funcp = (void(*)(int, int)) dlsym(Handle, "myfunc");
    `dlsym()`函数根据动态链接库句柄和要引用的符号，返回符号对应的地址。一般需要先定义一个指向这种符号类型的指针，用来保存该符号对应的地址。通过这个指针，就可以引用动态库里的这个函数或全局变量了。
3. 关闭动态链接库

        int dlclose(void *Handle);
    
    该函数会将加载到内存的共享库的引用计数减一，当引用计数为0时，该动态共享库便会从系统中被卸载。
4. 动态加载错误函数

        const char *dlerror(void);
    当动态链接库操作函数失败时，`dlerror`将返回错误信息。若没有出错，则`dlerror`的返回值为`NULL`。

可以将`sub.c`封装成一个插件，然后利用上面的系统调用，在`main()`中显示加载并调用。


# Linux内核模块运行机制

Linux内核实现了一个比较酷的功能：支持模块的动态加载和运行。如果实现了一个内核模块并打算运行，不需要重启系统，在Linux系统运行期间，直接使用`insmod`命令加载即可。像补丁一样打进了Linux系统，并可以正常运行。也可以动态卸载这个模块。

内核模块的运行原理与共享库的运行机制一样，都是在运行期间加载到内存。然后进行一系列空间分配，符号解析，重定位等操作。

内核模块文件本质上和静态库、动态库一样，是一个可重定位的目标文件。可以通过`readelf -h xxx.ko`命令查看这个目标文件的文件头信息。

内核模块（`.ko`）文件和动态库的不同处在于，一个运行在内核空间，一个运行在用户空间。应用程序的运行依赖C标准库实现的动态链接器完成动态链接过程，而内核模块的运行不依赖于C标准库，动态链接、重定位的过程需要内核自己完成：模块的加载实现由系统调用`init_module`完成。

使用`insmod`命令加载一个内核模块时的流程：
1. `kernel/module.c/init_module`；
2. 复制到内核：`copy_module_from_user`；
3. 地址空间分配：`layout_and_allocate`；
4. 符号解析：`simplify_symbols`；
5. 重定位：`apply_relocations`；
6. 执行：`complete_formation`

# Linux内核编译和启动分析

Linux的内核镜像`uImage`的编译流程：
1. 编译器将所有的源文件编译成对应的目标文件；
2. 将所有的目标文件链接成`ELF`格式的可执行文件`vmlinux`；

    - `ELF`文件是Linux环境下的可执行文件格式，无论是`GCC`还是`arm-linux-gcc`，最终生成的都是`ELF`文件。加载器根据`ELF`文件中的地址信息，就可以将其加载到内存指定的地址运行。
    - Linux内核是在裸机环境下启动的，没有`ELF`文件的执行环境，需要将`ELF`文件转化成`BIN/HEX`格式的纯二进制指令文件
3. 编译器调用`objcopy`命令删除`vmlinux`可执行文件中不必要的`section`，只保留代码段、数据段等必要的`section`，将`ELF`格式的`vmlinux`文件转换为原始的二进制内核镜像`Image`；
4. `Image`是纯指令文件，体积较大（一般几十兆），使用`gzip`工具对其进行压缩，压缩成名为`piggz.gzip`的二进制内核镜像（一般为3MB），压缩的好处在于提高程序的启动速度。
    - 内核加载运行时，从`Flash`上读取镜像的速度很慢，先通过压缩，加载到内存之后再解压的操作，不仅可以节省`Flash`的存储空间（`NOR Flash`比较贵），还可以节省镜像的加载时间。
5. `piggz.gzip`是压缩文件，无法运行，需要链接一段解压缩代码。由于链接器只能处理`ELF`格式的目标文件，因此在链接之前需要将压缩文件`piggz.gzip`转化成可重定位的目标文件`piggz.gzip.o`。
6. `ARM`平台下，解压缩代码由`arch/arm/boot/compressed/`目录下的`head.o`、`misc.p`、`decompress.o`目标文件组成的，这部分解码代码使用`-fpic`参数编译生成，特点是与位置无关，放到哪里都可以执行，通过链接器与`piggz.gzip.o`一起组装成新的`ELF`文件`vmlinux`；
7. 使用`objcopy`将`vmlinux`转换成为纯二进制的镜像文件`zImage`，`zImage`可以直接烧写到`NOR Flash`或`NAND Flash`上，系统上电后加载到内存中运行。
8. 不同的嵌入式平台可能会使用不同的`BootLoader`来加载Linux内核镜像来运行，常见的有`U-boot`、`vivi`、`g-bios`等。
   - 使用`U-boot`引导内核的嵌入式平台通常会对`zImage`进一步转换，给它添加一个64字节的数据头，用来记录镜像文件的加载地址、入口地址、文件大小、`CPU`架构等信息。使用`U-boot`提供的`mkimage`工具将`zImage`镜像转化成`uImage`。


经过上述流程，`U-boot`可以引导的`uImage`内核镜像就生成了，整个Linux内核镜像的编译流程就结束了。

`mkimage`的常用参数如下：
- `-A`：指定`CPU`架构类型；
- `-O`：指定操作系统类型；
- `-T`：指定`image`类型；
- `-C`：采用的压缩方式有`none`、`gzip`、`bzip2`等；
- `-a`：内核加载地址；
- `-e`：内核镜像入口地址

`uImage`被加载到内存的不同地址时，都可以正常启动。

`U-boot`提供了`bootm`机制来启动内核的运行。`bootm`会解析出`uImage`文件中64字节的数据头，解析出指定的加载地址，并和自己的启动参数比较。若`bootm`参数地址和编译时`-a`指定的加载地址相同，就会直接跳过数据头，直接跳到`zImage`的入口地址执行。如果`bootm`发现自己对参数地址和`-a`指定的加载地址不同，就会把去掉64字节数据头的内核镜像`zImage`复制到编译时`-a`指定的加载地址处，然后跳到该地址执行。

`zImage`是一个压缩文件，在运行之前要先解压出真正要执行的内核镜像`Image`，然后才能跳到内核镜像真正的入口处去启动Linux内核。解压缩代码`head.o`和`decompress.o`是一段与位置无关的代码，放到内存的任何位置都可以运行。


解压缩的主要作用是从`zImage`中解压出真正的内核镜像`Image`，并将其重定位到编译`Image`时指定的链接地址上。Linux内核运行使用的是虚拟地址，需要`CPU`硬件管理单元`MMU`的支持，`MMU`将虚拟地址转化成为对应的物理地址。


为了避免`zImage`解压缩过程中，自身刚好占据了入口处的地址，那么解压缩的`Image`重定位到该处时，会覆盖掉自身正在运行的解压缩代码这种情况的发生，`zImage`会将这部分压缩和重定位代码复制到一个安全的地方，如`Image`后面，然后跳到这片重定位代码处执行，这样就可以将`Image`镜像安全复制到入口地址上。


# U-boot重定位分析

## 嵌入式系统上电后流程

在嵌入式系统中，经常会使用`U-boot`引导Linux内核启动。`U-boot`不仅充当了`加载器`的作用，引导Linux内核镜像运行，还充当了`链接器`的作用，完成自身代码的复制及重定位。

`U-boot`其实并不是系统上电后的第一行代码。现在的`ARM`芯片内部一般会集成一个`ROM`，`ROM`上会有一段启动代码`ROMCODE`。其作用就是初始化存储接口，建立存储映射，会根据`CPU`外部管脚或`eFuse`值来判断系统的启动方式。


一个嵌入式系统通常支持多种启动方式，如`NOR Flash`、`NAND Flash`或者从`SD`卡启动。如果设置系统从`NOR Flash`启动，那么这段代码就会将`NOR Flash`映射到零地址，然后系统复位，`CPU`跳到`U-boot`中断向量表中的第一行代码，即`NOR Flash`中的第一行代码去执行。

也可以设置从`NAND Flash`或者`SD`卡启动，但是除了`NOR Flash`和`SDRAM`支持随机读写，可以直接运行代码，其他的`Flash`不支持直接运行代码，只能将代码复制到内存中执行。因为系统刚上电，内存还没有初始化，所以系统一般会将`NAND Flash`或`SD`卡的一部分代码复制到芯片内部的`SRAM`中执行，映射`SRAM`到零地址，然后在这一部分代码中进行各种初始化、代码复制、重定位等工作，最后`PC`指针才跳到`SDRAM`内存中去执行代码。


不论是哪一种启动方式，`U-boot`在启动过程中，都会将存储在`ROM`上的自身代码复制到内存中重定位，然后跳转到内存`SDRAM`中去执行。

![U-boot代码自复制和重定位](https://pica.zhimg.com/70/v2-45cd2df9cd2e97d604f6f8adf459e261_1440w.avis?source=172ae18b&biz_tag=Post)

[参考链接](https://zhuanlan.zhihu.com/p/543586959)

## U-boot的编译过程

`U-boot`在系统上电后启动过程中会涉及以下几个文件：
- `arch/arm/lib/vector.S`：`b reset`->`reset`
- `arch/arm/cpu/armv7/start.S`：`reset`->`_main`
- `arch/arm/lib/crt0.S`：`main`->`relocate_code`
- `arch/arm/lib/relocate.S`：`relocate_code`

系统复位上电后，`ARM`首先会跳到中断向量表执行复位程序，`reset`复位程序定义在`start.S`汇编文件中，`PC`指针跳转到`start.S`中执行该程序。复位程序主要执行以下操作：
- 设置`CPU`为`SVC`模式
- 关闭`Cache`，关闭`MMU`
- 设置看门狗，屏蔽中断、设置时钟，初始化`SDRAM`；

`reset`会调用不同的子程序完成各种初始化，最后跳转到`crt0.S`的`_main`汇编子程序执行。

在`_main`中主要执行以下操作：
- 初始化C语言运行环境、堆栈设置；
- 各种板级设备初始化、初始化`NAND Flash`、`SDRAM`
- 初始化全局结构体变量`GD`，在`GD`中有`U-boot`的实际加载地址
- 调用`relocate_code`，将`U-boot`镜像从`Flash`复制到`RAM`
- 从`Flash`跳到内存`RAM`中继续执行程序
- `BSS`段清零，跳入`bootcmd`或`mian_loop`交互模式

老版本的`U-boot`一般默认链接地址等于加载地址，而新版本的`U-boot`采取不同的操作，无论编译时链接地址是多少，`U-boot`可以根据硬件平台实际`RAM`的大小灵活设置加载地址，并保存在全局数据`gd-relocaddr`中。通过这种方式可以更大程序地适配不同大小的内存配置，不同的启动方式和不同的链接地址。


内核镜像一般被加载到内存的低地址，`U-boot`一般被加载到内存的高端地址，这样，当`U-boot`在复制内核镜像到内存时，可以防止覆盖掉自己，而且`U-boot`可以驻留在内存里面，当使用`reboot`软重启Linux系统时，还可跳回`U-boot`执行。


`U-boot`使用两个零长度数组`_image_copy_start`和`_image_copy_end`来标记`U-boot`中要复制到内存中的指令代码段。在复制之前，要先判断链接地址`_image_copy_start`和保存在`R0`中的实际加载地址`gd-relocaddr`是否相等。如果相等，则跳过复制过程。

`U-boot`复制到内存中，还需要对其重定位，然后才能跳到`RAM`中运行。

旧版本的`U-boot`在进行重定位之前，会先判断，当前运行地址是否等于链接地址，如果两者相等或者直接从`SDRAM`启动，则不需要重定位。新版本的`U-boot`无论哪种启动方式都需要重定位。


`U-boot`的重定位操作与动态链接库类似，采用地址无关代码+符号表的形式来完成重定位：符号表中保存的是代码中引用的绝对符号地址，如全局变量的地址、函数的地址等。符号表紧挨着代码段，位置在编译的时候就已经定死，程序在访问全局变量的时候，可先通过相对寻址跳到符号表，在符号表中找到变量的真实地址，然后就可以直接访问变量了。

具体重定位细节可以参考《嵌入式C语言的自我修养》Page[183-185]


# 常用的binutils工具集

具体可以参阅《嵌入式C语言的自我修养》Page[185]