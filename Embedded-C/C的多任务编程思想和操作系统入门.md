# 多任务的裸机实现

基于C51单片机实现一个温度控制系统，对大棚温度进行控制。用户可以通过按键设置预定温度，系统通过温度传感器获取当前的温度，并通过数码管显示。当温度低于设定温度时，系统会启动加热装置提高温度。


## 多任务的模拟实现

通过模块化设计方法，温度控制系统可以分为不同的模块：按键扫描、数码管显示、温度获取、温度加热。

    //task_v1.c
    #include <stdio.h>

    void delay(int ms)
    {
        for(int i=0; i<5000000; i++)
        {
            for(int j=0; j<ms; j++)
                ;
        }
    }

    int task_key_scan(void)
    {
        int key_value;
        printf("keyboard scan...\n");
        return key_value;
    }

    void task_led_show(void)
    {
        printf(led show...\n);
    }

    void task_temperture_get(void)
    {
        printf("DB18S20 init...\n");
    }

    void task_temperture_set(void)
    {
        printf("set temperture...\n");
    }

    int main(void)
    {
        while(1)
        {
            task_temperture_get();
            delay(100);
            task_led_show();
            delay(100);
            task_key_scan();
            delay(100);
            task_temperture_set();
            delay(100);
            printf("\n\n");
        }
        return 0;
    }

## 改变任务的执行频率

比如数码管显示、按键扫描任务需要频繁执行，否则用户的按键事件可能检测不到。数码管的动态刷新率低了，数码管的显示可能就会闪烁。有些任务，如温度获取和设置，温度变化很缓慢，不需要每秒都获取数据。

    //task_v2.c
    #include <stdio.h>

    unsigned int count;     //定义一个全局计数器

    void count_add(void)
    {
        for(int i=0; i<5000000; i++)
        count++;
    }

    int task_key_scan(void)
    {
        int key_value;
        printf("keyboard scan...\n");
        return key_value;
    }

    void task_led_show(void)
    {
        printf(led show...\n);
    }

    void task_temperture_get(void)
    {
        printf("DB18S20 init...\n");
    }

    void task_temperture_set(void)
    {
        printf("set temperture...\n");
    }

    int main(void)
    {
        while(1)
        {
            count_add();
            if(count % 1000 == 0)
                task_temperture_get();
            if(count % 100 == 0)
                task_led_show();
            if(count % 200 == 0)
                task_key_scan();
            if(count % 2000 == 0)
                task_temperture_set();    
        }
    }

在实际的嵌入式系统中，`count_add()`就会使用一个定时器或者时钟中断函数`rtc_interrupt`来代替。

## 改变任务的执行时间

尝试将运行时间耗时较长的任务分解成多个子任务，分阶段执行，通过状态机来实现。

对于数码管显示，每次只刷新一个数码管，通过状态机的有限个状态来标记每次刷新的情况。

对于按键任务，分解成按键按下，按键消抖，按键释放3个子任务，然后使用状态机记录不同的状态，分阶段执行，解决任务运行时间过长的问题。

    //task_v4.c
    #include <stdio.h>

    unsigned int count;

    void rtc_interrupt(void)
    {
        for(int i=0; i<500000; i++)
        count++;
    }

    void task1(void)
    {
        static int task1_state = 0;
        switch(task1_state)
        {
            case 0:
                task1_state++;
                printf("task1:step 0\n");
                break;
            case 1:
                task1_state++;
                printf("task1:step 1\n");
                break;
            case 2:
                task1_state++;
                printf("task1:step 2\n");
                break;
            case 3:
                task1_state++;
                printf("task1:step 3\n");
                break;
            default:
                printf("task1: undefined step\n");
                break;
        }
    }

    void task2(void)
    {
        static int task2_state = 0;
        switch(task2_state)
        {
            case 0:
                task2_state++;
                printf("task2:step 0\n");
                break;
            case 1:
                task2_state++;
                printf("task2:step 1\n");
                break;
            case 2:
                task2_state++;
                printf("task2:step 2\n");
                break;
            case 3:
                task2_state++;
                printf("task2:step 3\n");
                break;
            default:
                printf("task2: undefined step\n");
                break;
        }
    }

    int main(void)
    {
        while(1)
        {
            if(count % 1000 == 0)
                task1();
            if(count % 2000 == 0)
                task2();
            rtc_interrupt();
        }
        return 0;
    }


# 操作系统基本原理

上面的程序通过计数器和状态机可以改变每个任务的执行频率和执行时间，但是还有一个问题无法解决：无法修改每个程序的执行顺序。优先级高的任务应该优先执行。

    //task_v5.c

    #include <stdio.h>
    #include <unistd.h>
    #include <signal.h>

    int task_delay[4] = {0};

    void task1(void)
    {
        task_delay[0] = 10;
        printf("task1...\n");
    }

    void task2(void)
    {
        task_delay[1] = 4;
        printf("task2...\n");
    }

    void task3(void)
    {
        task_delay[2] = 4;
        printf("task3...\n");
    }

    void task4(void)
    {
        task_delay[3] = 1;
        printf("task4...\n");
    }

    void timer_interrupt(void)
    {
        for(int i=0; i<4; i++)
        {
            if(task_delay[i])
                task_delay[i]--;
        }
        alarm(1);
    }

    void(*task[])(void) = {task1, task2, task3, task4};

    int main(void)
    {
        signal(SIGALRM ,timer_interrupt);
        alarm(1);
        int i;
        while(1)
        {
            for(i=0;i<4;i++)
            {
                if(task_delay[i] == 0)
                {
                    task[i]();
                    break;
                }
            }
        }
        return 0;
    }

程序运行结果:

    task1...
    task2...
    task3...
    task4...
    task4...
    task4...
    task4...
    task4...
    task2...
    task3...
    task4...
    task4...

定义了一个函数指针数组，用来存放各个任务的函数指针，高优先级的任务放在数组前面，低优先级的任务放在数组后面。在`main()`中，根据每个任务的延时是否到期，来决定是否执行这个任务。当两个优先级不同的任务同时到期时，高优先级任务的函数指针放在前面，会先遍历到，会先执行。

## 调度器工作原理

上面程序模拟的任务切换过程，其实模仿的就是操作系统任务切换的基本流程。对上面的程序进行封装，就接近操作系统的调度器模型。

    #include <stdio.h>
    #include <unistd.h>
    #include <signal.h>

    int task_delay[4] = {0};

    void task1(void)
    {
        task_delay[0] = 10;
        printf("task1...\n");
    }

    void task2(void)
    {
        task_delay[1] = 5;
        printf("task2...\n");
    }

    void task3(void)
    {
        task_delay[2] = 2;
        printf("task3...\n");
    }

    void task4(void)
    {
        task_delay[3] = 1;
        printf("task4...\n");
    }

    void timer_interrupt(void)
    {
        for(int i=0; i<4; i++)
        {
            if(task_delay[i])
                task_delay[i]--;
        }
        alarm(1);
    }

    void(*task[])(void) = {task1, task2, task3, task4};

    void os_init(void)
    {
        task_delay[0] = 10;
        task_delay[1] = 4;
        task_delay[2] = 4;
        task_delay[3] = 1;
        signal(SIGALRM, timer_interrupt);
        alarm(1);
    }

    void os_scedule(void)
    {
        int i;
        while(1)
        {
            for(i =0; i<4; i++)
            {
                if(task_delay[i] == 0)
                {
                    task[i]();
                    break;
                }
            }
        }
    }

    int main(void)
    {
        os_init();
        os_scedule();
    }

调度器是操作系统最核心的组件，主要功能就是负责任务的切换。在一个操作系统环境下，每一个任务都是无限循环的，如果调度器不去调度它们，这个任务会一直霸占着CPU，无限期运行下去。

调度器一般会按照时间片轮转法去切换任务：每个任务运行10ms，然后会有一个时钟中断或者软中断产生，打断当前正在执行的任务，调度器会夺取CPU的控制权，接着开始进行任务调度，切换其他任务占用CPU继续运行。

调度器一般分为可抢占型和不可抢占型。不可抢占型调度器按照时间片轮转给每个任务分配运行时间，时间到了会有一个中断产生，调度器夺取CPU的控制权，然后安排下一个任务执行。可抢占型内核指一个任务的时间片还没未到，就可以被高优先级的任务打断，抢占CPU，然后开始运行高优先级的任务。实时操作系统对时间要求比较严格，一般都是采用可抢占型内核。而非实时操作系统对时间的要求不是很高，一般采用不可抢占型内核。

## 函数栈和进程栈

在多任务环境下，每个任务在运行的过程中都有可能被随时打断。每个任务也需要一个任务栈。任务栈的主要作用有两个：
- 任务执行期间，函数调用需要的函数栈帧
- 保存被打断的任务现场：CPU的各种寄存器、状态寄存器、被打断地址等

在`uC/OS`多任务环境中，对于用户创建的每一个任务都需要显式指定一个任务栈

    void task(void *pd)
    {
        while(1)
        {

        };
    }

    OS_STK task_stack[1024];

    int main(void)
    {
        BspInit();
        OSInit();
        OSTaskCreate(task, (void*)0, &task_stack[1023], 1);
        OSStart();
    }

在`uC/OS`下使用`OSTaskCreate()`创建一个任务时，需要显式指定该任务的栈空间起始地址`&task_stack[1023]`。在`ARM`平台下，因为使用的是递减栈，所以要将数组的最高地址作为栈的起始地址，当有栈元素入栈时，栈从高地址向低地址方向不断增长。当任务运行时，各个函数调用过程中需要的栈帧空间都保存在这个数组里；当该任务被打断时，CPU寄存器、被打断的地址等任务现场也会保存在这个数组里。

在Linux环境下，对于每一个运行的程序，Linux都会封装成一个进程。每一个运行的进程都有对应的进程栈，这个栈一般位于用户空间的最高地址。

## 可重入函数

    int a[5] = {1,2,3,4,5};
    int b[5] = {5,4,3,2,1};

    int sum(int array[], int len)
    {
        static int sum = 0;
        for(int i=0; i<len; i++)
            sum+=i;
        return sum;
    }

    void task1()
    {
        sum(a,5);
    }

    void task2()
    {
        sum(b,5);
    }


假设在一个多任务环境中，`task1()`和`task2()`都会调用`sum()`，由于`sum()`中定义了静态变量，当在运行期间被打断后再次被调用，就有可能影响`sum()`在`task1`和`task2`的运行结果。

在一个多任务环境中，一个函数如果可以被多次重复调用，或者被多个任务并发调用，函数在运行的过程中可以随时随地被打断，并不影响该函数的运行结果，称这样的函数为可重入函数。如果一个函数不能多次并发调用，在执行过程中不能被中断，否则就会影响函数的运行结果，那么这个函数就是不可重入函数，如上面的`sum()`函数。

判断一个函数是否为可重入函数：
- 函数内部使用了全局变量或者静态局部变量
- 函数返回值是一个全局变量或者静态变量
- 函数内部调用了`malloc()/free()`
- 函数内部使用了标准`I/O`函数
- 函数内部使用了其他不可重入函数

在裸机环境下，不需要考虑函数的可重入问题，因为裸机只有一个主程序。在多任务环境下，让一个函数变得可重入：
- 函数内部不能使用全局变量或者静态局部变量
- 函数返回值不能是全局变量或者静态变量
- 不使用标准`I/O`函数
- 不使用`malloc()/free()`函数
- 不调用不可重入函数

## 临界区和临界资源

操作系统可以通过信号量、互斥量、锁等机制对这些资源进行互斥访问，一次只允许一个任务访问这些资源，同一时刻也只允许一个任务访问这些资源。如全局变量、静态变量、缓冲区、打印机等，这些资源被称为临界资源。

与临界资源对应的是临界区，所谓临界区其实就是访问临界资源的代码段。临界区的访问方式是互斥访问，同一时刻只允许一个任务访问。在`uC/OS`环境下，临界区一般通过关中断的方式实现。在Linux/Windows环境下，临界区一般通过加锁、解锁的方式实现。


# 中断

在多任务环境下，通过中断来实现任务切换，在实际的操作系统调度器中，也是通过中断来完成进程调度和任务切换的。

不光是任务切换，操作系统的系统调用，内存管理等各种机制也是基于中断实现的。

## 中断处理流程

在计算机系统中，CPU同外部设备的通信一般分为两种方式：同步通信和异步通信，对应的实现方式分别是轮询和中断。轮询好比烧开水，烧的过程中什么都不做，每隔1分钟看一下水烧开了没有，中断就是烧水的过程中，去干别的事了，水烧开后，鸣笛通知。中断的好处就是不占用CPU资源。

对于串口、鼠标键盘这种慢速设备，如果采用轮询的方式，会白白浪费CPU的资源，采用中断这种异步通信方式就不会存在这种问题。外部设备在数据发送和接收的过程中，CPU该干啥干啥，两者不冲突，等外部设备的接收或发送完毕，以中断的形式通知CPU，CPU再来处理。

不同的外部设备可能产生不同的中断，为了区分，引入中断号或中断线的概念。对于每一个外部设备都有一个固定的中断号。`SoC`芯片内部通常会集成一个专门管理中断的模块：中断控制器。

中断控制器通常通过一根或两根中断信号线和CPU相连。当外部设备发生中断时，会首先将中断信号传送到中断控制器，中断控制器通过中断屏蔽、优先级、中断是否使能等各种条件判断和检测，然后将中断信号发送到CPU，CPU检测到中断之后，就会搁置当前正在执行的任务，查看相关寄存器，看是哪个设备发生了中断，再跳转到对应的中断处理程序执行中断操作。


上面的中断称为外部中断。除此之外，还有CPU在执行程序过程中遇到未定义指令，或者运行出错了也会发生中断，只不过这种中断来自于CPU内部而不是外部设备。

CPU内部异常、外部中断和软中断都属于中断的范畴。

ARM处理器有多种中断模式，如`Reset`、`Undefined Instruction`。当中断发生时，ARM处理器中的`PC`指针会跳到中断向量表去执行，根据发生的中断的类型，跳转到向量表中不同的入口地址上。对于每一种中断模式，在向量表中只有一个字的存储空间，因此在向量表中存储的往往是一条跳转指令。当发生中断时，跳转到不同的中断处理函数中执行。

![ARM的中断向量表](https://s2.51cto.com/images/blog/202108/02/90696baa80b01083f8ae8fb9bf1b4d02.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp)

[参考链接](https://blog.51cto.com/u_15127681/4598317)




## 进程栈与中断栈

在一个多任务环境中，每个任务都要有自己的任务栈，一是为了给函数调用过程中的每个函数准备栈帧空间，二是当该任务被打断时，需要将该任务的现场环境保存到当前的任务栈中。


在一个多任务环境中，CPU如果想要运行一个任务，直接将CPU内部的`PC`指针指向这个任务的函数体即可。`PC`指向哪里，CPU就到哪里取址运行。程序运行时，还需要将CPU内部的寄存器`SP`指向一个栈空间，因为函数内的局部变量、传递的实参、返回值都是保存在栈内的，没有栈，C语言就无法运行。CPU对栈内数据是通过`FP/SP+`相对偏移实现的。

因为是相对寻址，所以栈与位置是无关的，把栈放到内存中的任何地方都不会影响程序的运行。只要提供一片内存空间，`SP`指针指向哪里，CPU就可以在哪里建立函数运行的栈帧环境；`PC`指针指向哪里，CPU就到哪里去取指令，运行一个个C语言函数。

![进程栈和函数栈帧](https://s2.51cto.com/images/blog/202301/12174542_63bfd6c6dda1294946.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)

[参考链接](https://blog.51cto.com/u_15202985/6010015)

只要提供一片内存，无论在什么地方，函数都能正常运行。

当CPU运行不同的任务时，让`SP`指针分别指向每个任务各自的任务栈。

ARM处理器属于`RISC`架构，不能直接处理内存中的数据，要先通过`LDR`指令将内存中的数据加载到寄存器，处理完毕后再通过`STR`指令写回到内存中。每一次数据的处理过程都需要加载/存储操作来辅助完成。如果在CPU处理数据的过程中任务被打断，保存现场时这些寄存器的值也都要保存起来，再加上ARM处理器中的状态寄存器`CPSR`等，它们和`PC`，`SP`等寄存器一起构成了程序运行的现场，即任务的上下文环境。


在操作系统的源码实现中，调度器为了更好地管理一个任务，一般会为每个任务定义一个结构体，每个结构体内都有指向当前任务函数体和进程栈的指针。各个任务的结构体通过指针链接成一个双向循环链表，调度器通过这个链表来管理和调度每一个任务。


当一个正在运行的任务被打断，CPU切换到另一个任务执行之前，首先要做的是保存当前任务的现场，即任务的上下文，包括`PC`指针、`SP`指针、各种寄存器等。这些现场一般会保存到各个任务的任务栈中。以`task3`为例，当`task3`不再运行时，它的任务上下文会首先保存到自己的任务栈中，然后将`task2`的上下文环境恢复到CPU的`PC`，`SP`等寄存器。此时，`PC`指针指向`task2`的代码段，`SP`指针指向`task2`的任务栈空间，CPU开始执行`task2`，如果`task2`执行一段时间后再被切换出去执行`task3`，操作系统会首先保存`task2`的任务上下文到它的任务栈，然后把`task3`的任务上下文弹出到CPU即可，`task3`就像没有被打断过一样，从原来被打断的地方继续运行。


Linux中，一个进程空间被分成了内核空间和用户空间。Linux普通进程运行在用户空间，进程运行需要的栈也是在用户空间，这种栈被称为进程栈。当用户程序调用系统调用函数时，操作系统就会由用户态转为内核态，CPU开始执行内核里的代码，内核代码运行的过程中，各种函数调用也需要栈空间。Linux操作系统一般会在内核空间给每个进程都分配4KB或者8KB的栈空间，称为内核栈。


当一个进程在用户态和内核态交互运行时，就会用到两种进程栈，这时就涉及到`SP`指针的切换。一个进程的用户栈和内核栈会通过结构体的一些指针进行关联，`SP`栈指针可以通过这些关联信息进行切换。


除了用户栈和内核栈，一个程序在运行的过程中，还会用到中断栈。当中断发生时，CPU会通过中断向量表跳转到跳转到对应的中断处理函数中运行。中断处理函数也是函数，运行中断处理函数时候会需要栈的支持。中断处理函数的各级函数调用、被中断打断时的现场保护也需要栈空间，这个栈称为中断栈。


中断栈分为两种：独立中断栈和共享中断栈。独立中断栈有自己独立的栈空间，而共享中断栈则和任务栈共享内存空间。一个任务在执行期间被中断打断后，`SP`指针会指向会指向中断栈，`PC`指针会指向中断处理函数，CPU就跳转到中断处理函数中去执行了。如果此时再来一个中断，发生了中断嵌套，操作系统会把当前的中断上下文保存到中断栈中，然后跳转到新的中断函数中执行。


在Linux环境下，发生中断时，操作系统一般都会进入内核态，所以中断栈会和Linux内核栈共享存储空间。操作系统给为每个进程的内核栈分配的空间并不大。所以在编写中断函数的时候需要注意栈空间的使用情况。中断函数内一般不使用大块内存，中断函数的调用层数，中断嵌套也不能太深，防止因为中断栈溢出而导致系统崩溃。

## 中断函数的实现

编写中断函数应该注意的地方：
- 中断函数被调用的时间不固定：中断函数需要自己保护现场
- 中断函数被调用的地点不固定：当前的任务无法给中断函数传参
- 中断函数的返回地点不固定：中断函数不能有返回值

中断函数基本流程：
- 保存中断现场：状态寄存器、返回地址入栈、中断`ISR`中要用到的寄存器入栈；
- 清中断：关中断，保护现场。有些硬件会自动清除，重开中断前记得要清除；
- 执行用户编写的中断处理函数；
- 恢复现场：将栈中保存的数据弹到CPU的各个寄存器中，恢复被中断的现场，从栈中弹出返回地址到`PC`寄存器，CPU从被打断的程序处继续执行。

底层的现场保存和恢复交给编译器来完成。只需要关注业务逻辑就可以。

基本原则：
- 中断函数不能有返回值；
- 不能向中断函数传递参数；
- 不能调用不可重入函数，如`printf()`
- 不能调用引起睡眠的函数
- 中断函数短小精悍、快速执行、快速返回。

在一个多任务环境中，中断处理函数还涉及任务调度问题。当中断处理完毕要退出时，不一定会返回到原先被打断的任务继续执行，它会找出当前优先级最高的就绪任务。

在Linux环境下，还有一些规则需要注意：
- 中断的上下文中，要禁止任何进程切换；
- 在中断函数处理过程中不能调用可能会引起任务调度的函数，如一些可能会引起CPU睡眠的函数，引起阻塞的函数，或者其他一些导致调度器介入执行，发生任务切换的函数。

# 系统调用

函数级的代码复用，库级的代码复用，框架级的代码复用前面都介绍过。在多任务环境下的任务创建、任务切换和任务管理等代码不断优化和迭代，封装成一个操作系统，留出相关的`API`函数供应用程序调用，实现操作系统级的代码复用

## 操作系统的API

假设有个APP开发者，调用了操作系统的一些`API`，对硬件进行一些非法操作或者对内存进行了非法访问，篡改了操作系统内核的一些核心代码，可能会导致整个系统崩溃。

## 操作系统的权限管理
Linux操作系统运行时一般分为内核态和用户态，应用程序运行在用户态，操作系统内核和驱动运行在内核态，操作系统在内核态时可以访问系统任意资源，而用户程序在用户态时访问这些资源则会受限。

如果应用程序想要访问一些受限制的系统资源，可以通过Linux操作系统预留的专门的系统调用`API`供用户使用。通过系统调用，Linux会从用户态转换到内核态，然后就有权限访问任意资源。


## CPU的特权模式
不同的CPU有不同的运行等级，如`X86`处理器就有4个运行等级，分别为`ring0`，`ring1`，`ring2`，`ring3`。`ring3`等级最低，一般应用程序运行在这个等级，对应操作系统的用户态，`ring0`是特权等级，操作系统内核代码运行在这个等级，对应操作系统的内核态。

ARM处理器也有不同的运行等级，一般分为用户模式和特权模式。

应用程序一般运行在用户态，CPU工作在普通模式，当CPU发生外部中断、内部异常或系统调用时，CPU就会进入特权模式，操作系统进入内核态，CPU开始执行特权级内核代码。

以系统调用`open`为例，CPU从系统调用到执行内核代码，到返回用户态继续执行应用程序的代码，基本流程如下：
- 应用程序解析参数，调用系统调用：`open`
- Linux进入内核态，CPU进入特权模式，控制权交给OS，参数放在寄存器中
- CPU从系统调用表中查询`open`系统调用对应的代码内存地址
- 从寄存器获取参数，执行`open`对应的操作系统内核代码
- 内核代码执行结束，将运行结果复制到用户态
- CPU由特权模式切换到普通模式，操作系统用内核态返回到用户态
- CPU执行用户态代码，继续在用户态运行。

系统调用的优点：
- 简化应用程序开发，分离用户程序和内核驱动，为应用程序提供一个统一的硬件抽象接口
- 通过权限管理，在一定程度上保证了系统的安全与稳定


## Linux系统调用接口

|系统调用|举例|
|-|-|
|文件操作|`open`，`close`，`read`，`write`，`lseek`，`fsync`|
|进程控制|`fork`，`clone`，`execve`，`exit`，`getpid`，`pause`|
|文件系统|`mkdir`，`mknod`，`rmdir`，`chmod`，`rename`，`mount`|
|系统控制|`time`，`uname`，`reboot`，`alarm`，`ioctl`|
|内存管理|`brk`，`mmap`，`munmap`，`sync`|
|信号|`signal`，`kill`|
|`socket`控制|`socket`，`bind`，`connect`，`send`，`listen`，`shutdown`|

由于Linux系统有不同的发行版本，不同的系统调用接口需要符合`POSIX`标准，为不同的Linux和UNIX操作系统统一了应用程序系统调用接口。

# 揭开文件系统

从用户层面看，无论是手机上的app还是计算机上的播放器，它们的操作对象是一个个文件，而不是存储在底层硬件设备上的一串串二进制数据。从底层物理存储设备上的二进制数据到不同目录下的具体文件名，这个转换过程就是文件系统完成的。

## 文件系统是什么

文件系统就是一个存储管理程序，通过对不同物理存储设备进行抽象和管理，呈现给用户的操作接口是人类更容易接受的目录和文件的形式。文件系统对存储设备进行抽象封装，向用户提供一组目录和文件操作的`API`。当用户使用这些`API`新建一个文件时，文件系统就会建立该文件到实际物理存储之间的映射，直接通过文件名访问即可。

一个刚出厂的存储设备，如U盘，里面其实就是一个个的存储单元阵列。使用之前需要先格式化，格式化时需要选择一种文件系统类型。所谓格式化，就是让文件系统去管理这块存储空间。文件系统将原始存储空间划分成大小相同的块，建立文件名，目录名到实际物理存储地址的映射关系，并将这些映射关系存储在某块物理存储单元内。

当格式化一个U盘时，文件系统会将U盘的物理存储单元划分为大小相等的逻辑块`block`，`block`是文件系统存储数据的基本管理单元。文件系统将U盘的存储空间分为两部分：纯数据区和元数据区。

![inode table](https://img-blog.csdnimg.cn/img_convert/6a40bdfff3efa97a4fa510fbb091ba18.png)

[参考链接](https://blog.csdn.net/weixin_42316319/article/details/116554395)

纯数据区是文件真正的数据存储区，而元数据区则用来存储文件的相关属性：该文件在磁盘中的存储位置、文件的长度、时间戳、读写权限、所属组、链接数等文件信息。

文件系统中的每一个文件都用一个`inode`结构体来描述，用来存储文件的元数据信息。每个`inode`都有固定的变化和单独的存储空间，每个`inode`都为128字节或者256字节大小。Linux系统根据元数据区的`inode`来查找文件对应的物理存储位置。

当用户通过指定的路径文件名去读写一个文件时，文件系统会根据目录项中的文件名和`inode`编号之间的对应关系，会到存储在元数据区的索引节点表中，找到该文件对应的`inode`节点。根据`inode`节点信息，找到文件在磁盘上的具体存储位置。

## 文件系统的挂载

如果想要访问某个存储设备，一般需要将该存储设备挂载到文件系统的某个目录上，然后对该挂载目录的读写操作就相当于对该存储设备的读写操作。将一个存储设备`mount`到一个目录的本质，其实就是改变该目录到具体物理存储的映射关系，让该存储设备与要挂载的某个目录建立关联，加入全局文件系统目录树中。

## 根文件系统

Linux内核在初始化过程中，首先会创建一个根目录`/`，然后`mount`第一个文件系统到这个根目录下，这个文件系统就被称为根文件系统。其他的存储分区，磁盘，`SD`卡，U盘接着就可以`mount`到根文件系统的某个目录下，然后用户就可以通过文件接口访问各个不同的存储设备。

在Windows环境下，每个盘符就相当于一个根目录，每一个磁盘分区都可以使用不同的文件系统格式化，各个文件系统以盘符为根目录，然后用户就可以以“目录路径+文件名”的形式访问各个磁盘分区上的文件。

Linux环境下，一个根文件系统会包含Linux运行所需要完整目录和相关的启动脚本、配置文件、库、头文件等。
- `/bin`、`/sbin`：存放Linux常用的命令，以二进制可执行文件形式存储在该目录下
- `/lib`：用来存放Linux常用的一些库，如C标准库
- `/include`：头文件的存放目录
- /`etc`：用来存放系统的配置文件、启动脚本等
- `/mnt`：常用来作为挂载目录

# 存储器接口与映射

一个嵌入式系统会支持多种启动方式：从`NOR Flash`启动，从`NAND Flash`启动或者从`SD`卡启动。

## 存储器与接口

存储器接口按照访问方式一般分为3种接口：


1. `SRAM`接口是一种全地址、全数据线的总线接口，地址和存储单元是一一对应的，支持随机寻址，CPU可以直接访问，随机读写。`SRAM`和`Nor Flash`一般都采用这种接口和CPU相连。

2. `DRAM`接口没有采用全地址线方式，而是采用行地址选择+列地址选择的地址形式，地址线是复用的，一个地址需要多个周期发送。CPU不能通过地址线直接访问`DRAM`，要通过`DRAM`控制器按照规定的时序去访问`DRAM`的存储单元。`DRAM`和`SDRAM`一般都是采用`DRAM`接口和CPU处理器相连。

3. 串行接口，通常以串行通信的方式发送地址和数据，读写速度相比于前两者更慢，但优势是接口的管脚比较少，因此占用CPU的管脚资源相对较少，像`E2PROM`，`NAND Flash`，`NOR Flash`一般都采用这种方式和CPU相连。
 

## 存储映射

存储映射就是，其实就是`SRAM`中的存储单元分配逻辑地址过程。

存储映射的具体实现与处理器有关，不同的处理器有不同的实现方式。无论采用哪种映射方式，存储器的映射一般都会在复位前由CPU自动完成，复位之后的CPU默认会从零地址开始执行代码。

## 嵌入式启动方式

CPU上电后会首先运行固化在CPU芯片内部的一小段代码`ROMCODE`。这部分代码的主要功能就是初始化存储器接口、建立存储映射。首先根据CPU管脚或者`eFuse`值来判断系统的启动方式：从`NOR Flash`，`NAND Flash`启动还是`SD`卡启动。

如果将`U-boot`代码烧写在`NOR Flash`上，设置系统从`NOR Flash`启动，这段`ROMCODE`会将`NOR Flash`映射到零地址，然后系统复位，CPU默认从零地址取代码执行，即从`NOR Flash`上开始执行`U-boot`指令。

如果系统从`NAND Flash`或者`SD`卡启动，因为除了`SRAM`和`NOR Flash`支持随机读写，可以直接运行代码，其他`Flash`设备是不支持代码直接运行的，因此只能将这些代码从`NAND Flash`或者`SD`卡复制到内存中运行。

# 内存与外部设备

## 内存与外存

计算机的存储设备按照存取速度排列，可以分为寄存器，缓存，内存，外存。寄存器和缓存就是CPU内部的寄存器和Cache。寄存器和Cache的物理电路实现其实都是`SRAM`，`SRAM`电路实现复杂，物理成本高，占用的芯片面积大，功耗高，因此在CPU内部的容量一般不是很大。


内存一般称为主存，是CPU可以直接寻址的存储空间，存取速度快，常见的内存包括`RAM`，`ROM`，`NOR Flash`等。外存一般称为辅存，是除了CPU缓存和内存外的存储器，包括磁盘、`NAND Flash`、`SD卡`，`EEPROM`等。

## 外部设备

从程序存储的角度看，计算机存储可以分为内存和外存。如果从程序运行的角度看，和内存对应的是外部设备，简称外设。程序运行的主要目的就是处理各种数据，这些数据有些事程序本身，有些则是CPU与外部设备进行通信获取。

在一个嵌入式`SoC`芯片中，往往集成了`UART`，`USB`，`I2C`，`GPIO`等各种控制器IP。主要作用如下：
- 设备控制：设备的打开、关闭、运行都可以通过配置相关寄存器来完成
- 协议控制：`USB`，`I2C`，`UART`，`I2S`，控制器在电气层会实现各种通信协议
- 数据转换：序列流、字节流
- 数据缓冲：缓冲区、`FIFO`，发送接收数据的缓冲区

CPU与外部设备通信，常见的有3种方式：轮询，中断和`DMA`

中断：外部设备控制器通过协议控制与外部设备进行数据传输，接收的数据会暂时保存到控制器内部的`FIFO`中。当`FIFO`里的数据已满或者达到一个设定阈值后就会产生一个中断，CPU检测到中断后就会进入相关的中断处理函数中执行。中断处理函数中，CPU会读取`FIFO`里的数据到寄存器，然后将寄存器中的数据保存到内存中的某块区域。发送数据的流程正好相反，CPU会首先到内存中的某块区域读取数据到寄存器，然后将寄存器中的数据填充到`FIFO`。填充完毕后，启动控制器开始发送，当控制器发送数据完成后会产生一个中断，CPU进入中断处理函数，继续填充`FIFO`，直到整个数据发送任务都完成。

在一个CPU中，`DMA`模块就是代替CPU充当中转站的角色的，`DMA`内部有缓存，它会将内存的数据先搬到`DMA`，然后通过`DMA`发送出去，就不需要CPU的参与了。数据传输任务完成之后，`DMA`会先产生一个中断，告诉CPU数据传输已经完成。

## I/O端口与I/O内存

CPU可以通过寄存器配置来控制外部设备控制器与外部设备进行通信。在一个外部设备控制器中，通常会包含各种控制寄存器、状态寄存器、`FIFO`、缓冲区等。CPU能否直接读取这些寄存器，需要看这些寄存器的编址方式。

一般将这些外部设备控制器的寄存器称为`I/O`端口，每一个寄存器对应一个端口。给这些`I/O`端口分配地址，一般有两种方式：独立编址和统一编址

`X86`架构的处理器一般对这些`I/O`端口独立编址，CPU不能像读写内存一样直接对这些端口进行读写，要通过专门的`IN/OUT`命令去读写这些端口来配置相关的寄存器。

ARM架构的处理器一般会将外部设备控制器这些寄存器、缓冲器、`FIFO`和内存统一编址，外部设备控制器的寄存器和内存一起共享地址空间，因此被称为`I/O`内存。CPU可以按照内存读写的方式，直接读写这些寄存器来管理和操作外部设备。


# 寄存器操作

在ARM处理器中，可以像操作内存一样对寄存器进行读写，进而配置控制器与外部设备进行通信。在一个32位的处理器中，一个寄存器位宽为32bit，不同的位可能代表不同的控制信息或状态信息，通常使用位运算来操作这些寄存器。

## 位运算应用

    #include <stdio.h>

    int main(void)
    {
        int i = 0xFF;
        printf("%X\n", 0xFF & 0x0);
        printf("%X\n", 0xFF | 0x0F);
        printf("%X\n", ~0xFF);
        printf("%X\n", 0x1 << 3);
        printf("%X\n", 0x1000 >> 4);

        printf("%X\n", 0^0);
        printf("%X\n", 0^1);
        printf("%X\n", 1^0);
        printf("%X\n", 1^1);
        return 0;
    }

程序运行结果

    0 
    FF 
    FFFFFF00
    8
    100
    0
    1
    1
    0

让一个数据的高位和低位互换

    #include <stdio.h>

    int main(void)
    {
        printf("%X\n", 0xAABB);
        printf("%X\n", 0xAABB >> 8 | 0xAABB << 8 & 0xFF00);
        return 0;
    }

程序运行结果

    AABB
    BBAA

使用类似`mask&(mask-1)`的程序语句，这个表达式用来判断一个数是否为2的整数次幂。

    #include <stdio.h>

    int main(void)
    {
        int m = 4;
        if((m&(m-1)) == 0)
            printf("%d is power of 2\n", m);
        else
            printf("%d isn't power of 2\n", m);
        return 0;
    }

还有其他的一些利用位运算实现的应用。

## 操作寄存器

如果想让一个32位的`0xFFFF0000`低4位置1，则可以将该数据和位掩码`0x0F`直接进行运算。如果要操作的位不是连续的，将位掩码转换为16进制比较麻烦，可能还需要手动计算。位掩码可以通过各个比特位进行或运算来生成。如果想要清除某些指定位。如将`0xFFFFFFFF`的bit4-bit7清零，可以让该数与位掩码`0xFFFFFF0F`做与运算

    int main(void)
    {
        printf("%X\n", 0xFFFFFFFF & 0xFFFFFF0F);
        printf("%X\n", 0xFFFFFFFF & ~(0x000000F0));
        printf("%X\n", 0xFFFFFFFF & ~(0x1<<4|0x1<<5|0x1<<6|0x1<<7));
        return 0;
    }

程序运行结果

    FFFFFF0F
    FFFFFF0F
    FFFFFF0F

## 位域

读写寄存器除了使用位掩码+位运算的组合方式，还可以直接使用位域直接操作寄存器。

位域一般与结构体类型结合使用：虽然结构体的成员由位域构成，但是结构体的本质不变，还是个结构体。唯一不同的是，结构体成员的存储是按照比特位分配的。

    struct register_usb{
        unsigned short en:1;
        unsigned short ep:4;
        unsigned short mode:3;
    };

在一个寄存器中，几个连续的比特位可以组成一个位域，用来表示寄存器的控制位或者状态位。通过定义一个结构体，可以使用不同的位域来表示这些不同的控制位或状态位。

    #include <stdio.h>
    #include <string.h>

    struct register_usb{
        unsigned short en:1;
        unsigned short ep:4;
        unsigned short mode:3;              //bit5-bit7表示USB的工作模式
    };

    int main(void)
    {
        struct register_usb reg;
        memset(&reg, 0, sizeof(reg));
        reg.en = 1;
        reg.ep = 4;
        reg.mode = 3;
        printf("reg:%x\n", reg);
        printf("reg.en:%x\n", reg.en);
        printf("reg.ep:%x\n", reg.ep);
        printf("reg.mode:%x\n", reg.mode);
        return 0;
    }
    
程序运行结果

    reg:69
    reg.en:1
    reg.ep:4
    reg.mode:3

位域还可以与联合体结合使用。

# 内存管理单元MMU

## 地址转换

内存管理单元MMU集成在CPU内部，主要用来将虚拟地址转换成为物理地址。每个APP编译时都以虚拟地址作为链接地址。甚至使用相同的链接地址都可以。当各个APP运行时，CPU会通过MMU将相同的虚拟地址映射到不同的物理地址，各个APP都会有各自的物理内存空间，互不影响各自的运行。


MMU是根据每个进程的地址转换表将相同的虚拟地址转换为不同的物理地址。当`PC`指针指向某个虚拟地址处取指令，经过MMU地址转换后，会到实际物理内存地址处取指令。不同的应用程序有着不同的地址转换表，相同的虚拟地址会映射到不同的物理地址上。


地址转换表虽然解决了地址转换的问题，但是很浪费内存：app1的大小为4KB，至少需要4KB大小的空间来存储这个地址转换表信息；app2的大小为8KB，则至少需要8KB大小的空间来存储app2的地址转换表信息。


将内存分割成4KB大小相同的内存单元，每个内存单元都被称为页或者页帧。以页为单位进行映射，地址转换表中只保存每个页的虚拟其实地址到物理起始地址的转换关系。这样就可以让原先的地址转换表的空间由4KB转化为1字节。此时的地址转换表一般被称为页表。

一个页表中有很多页表项，每个页表项里只有每个页的虚拟起始地址到物理起始地址的转换信息。对于一个具体的存储单元的虚拟地址，CPU一般会把这个虚拟地址分解成页帧号+页内偏移的形式，对于同一个虚拟地址`0x10004`，可以分解成`0x10+0x004`的形式，`0x10`是页帧号，`0x004`是页内偏移（因为使用的是4KB为单位划分页的，所以使用低12位表示4KB范围的页内偏移）MMU根据虚拟页的页帧号转换成为物理页的页帧号`0x30005`，再与页内偏移`0x004`组装。构成了物理地址`0x30005004`


页表是由操作系统维护的，由Linux内存管理子系统负责管理和维护，当地址完成转换后，会同步更新到用户空间的每一个进程中。

![MMU,TLB,页表](https://s2.51cto.com/images/blog/202112/13055412_61b66f84a98cc58941.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)

MMU每次地址转换，会首先从内存中读取页表，根据页表内的地址转换信息将一个个虚拟地址转换为物理地址。为了提高转换效率，会在CPU内部集成一个缓存`TLB`，用来缓存部分页表。当MMU地址转换时，会首先根据虚拟地址到`TLB`这个缓存中看是否有对应的地址转换信息。如果有，就不需要到内存中去取，如果没有，则MMU再到内存中取，同时`TLB`会重新缓存到这个新地址附近的转换信息。

## 权限管理
地址转换是MMU的基本功能，除此之外，MMU和页表还可以对不同的内存区域设置不同的权限，防止内存被践踏，保障系统的安全运行。

一个页表有若干个页表项构成，每个页表项不仅包含地址转换信息，还包含每一个进程中不同内存区域的访问权限信息。通过这种设计，就可以对不同用户进程映射到实际物理内存的地址空间进行权限管理。

# 进程、线程和协程

|多任务环境下的函数划分|说明|
|-|-|
|线程不安全函数|含有不可重入函数|
|线程安全函数|只含有可重入函数或者通过锁、关中断等机制实现互斥访问的不可重入函数|

在Linux环境下，可以通过`man`命令来查看该函数是否为线程安全函数。

## 进程

在Linux环境下运行一段程序，操作系统会把这个程序封装成进程的形式，每一个进程都使用`task_struct`结构体来描述，所有的结构体链成一个链表，参与操作系统的统一调度和运行。每个Linux进程都有单独的4GB的虚拟地址空间。Linux引入内存管理机制，使用页表保存每个进程中虚拟地址和物理地址之间的对应关系，通过MMU地址转换，每个进程相同的虚拟地址空间都会被映射到不同的物理内存，每个进程在物理内存空间都是相互独立和隔离的。

因为进程在物理内存上是相互隔离的，所以在多进程编程时，无论一个函数是否可重入，无论函数是否线程安全，在一个进程中都可以调用它们。

不同的进程需要相互通信，可以通过以下方法：
- 每个进程的1GB的内核空间是所有的进程共享的，不同的进程可以在内核空间开辟一片内存进行通信；
- 磁盘是所有进程共享的，可以通过磁盘文件相互传输数据；
- 通过共享内存，映射到同一片物理内存进行通信，效率更高；

Linux提供了各种工具来支持不同进程之间的通信：
- 无名管道：只能用于有
- 有名管道：任意两进程之间通信
- 信号量：进程间同步，包括`system V`信号量，`POSIX`信号量
- 消息队列：数据传输，包括`system V`消息队列，`POSIX`消息队列
- 共享内存：数据传输，包括`system V`共享内存，`POSIX`共享内存
- `Socket`：套接字缓冲区，不同主机不同进程之间的通信。


## 线程
多个线程共享进程中的代码段、数据段、地址空间、打开文件、信号处理程序等资源。每个线程都有自己单独的资源，如程序计数器，寄存器上下文及各自的栈空间。

多个线程共享进程的资源，可以通过互斥锁、条件锁和读写锁等同步机制来实现不同线程对共享资源的安全访问。

当程序调用加锁函数时，操作系统会从用户态切换到内核态，并阻塞在内核态；当程序调用解锁函数时，操作系统同样会从用户态到内核态，再从内核态到用户态的切换。

可以使用条件变量和互斥锁搭配使用，来减少不断加锁、解锁带来的开销。

互斥锁在同一时刻只允许一个线程进行读或写，使用读写锁，可以允许多个线程进行读操作，但是同一时刻只允许一个线程进行写操作，写的时候会阻塞其他线程（包括读线程），写线程的优先级高于读线程。


## 线程池

![进程中的多线程空间](https://aijishu.com/img/bVboqn)

[参考链接](https://aijishu.com/a/1060000000293144)

线程不断地创建和销毁，在一些频繁使用线程的场合，开销会线性上升。

预先在线程池中创建一些线程，没有任务工作时，线程阻塞在线程池中；有任务时，则通过管理线程将任务分配到指定的线程执行。


一个线程池由管理线程、工作线程和任务接口构成。管理线程用来创建并管理工作线程，将用户创建的不同任务分配给不同的工作线程执行。工作线程是线程池中执行实际任务的线程，无任务时，这些工作线程则阻塞在线程池中。线程池一般还会引出任务接口供用户调用，用户通过这个任务接口，创建不同的任务，并最终分配到不同的工作线程中执行。

