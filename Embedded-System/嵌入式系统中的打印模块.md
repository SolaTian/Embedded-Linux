# 嵌入式系统中的打印模块

在一些大型的嵌入式项目开发中，由于项目代码量十分巨大，且包含众多模块。在众多模块中，可以分成主模块和子模块。在实际开发和调试的过程中往往需要查看某几个子模块的打印。

比如嵌入式系统中，网络流量主模块，包含数据上传子模块和数据接收子模块。在实际的调试中，就需要精确到具体的子模块。


## 写一个自己的打印宏

打印一般包括几个常规等级。

- `ERROR`: 默认打开
- `WARN`：默认打开
- `INFO`：默认关闭
- `DBG`：默认关闭

希望能够通过自己设定打印等级，然后在程序中显示不同级别的打印

```c
//logger.h
#ifndef LOGGER_H
#define LOGGER_H

#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#include <string.h>

// 日志级别
typedef enum {
    LOG_LEVEL_ERR  = 0,  // 错误（红色）
    LOG_LEVEL_WARN = 1,  // 警告（黄色）
    LOG_LEVEL_INFO = 2,  // 信息（绿色）
    LOG_LEVEL_DBG  = 3   // 调试（蓝色）
} LogLevel;

// 初始化日志系统（默认输出到stderr）
void logger_init(FILE *output);

// 核心打印函数
void logger_log(LogLevel level, const char *file, int line, const char *fmt, ...);

// 快捷宏
#define LOG_ERR(fmt, ...)  logger_log(LOG_LEVEL_ERR,  __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_WARN(fmt, ...) logger_log(LOG_LEVEL_WARN, __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_INFO(fmt, ...) logger_log(LOG_LEVEL_INFO, __FILE__, __LINE__, fmt, ##__VA_ARGS__)
#define LOG_DBG(fmt, ...)  logger_log(LOG_LEVEL_DBG,  __FILE__, __LINE__, fmt, ##__VA_ARGS__)

// 彩色终端支持
#ifdef __linux__
    #define COLOR_RED     "\033[31m"
    #define COLOR_YELLOW  "\033[33m"
    #define COLOR_GREEN   "\033[32m"
    #define COLOR_BLUE    "\033[34m"
    #define COLOR_RESET   "\033[0m"
#else
    #define COLOR_RED     ""
    #define COLOR_YELLOW  ""
    #define COLOR_GREEN   ""
    #define COLOR_BLUE    ""
    #define COLOR_RESET   ""
#endif

#endif // LOGGER_H
```

```c
#include "logger.h"
#include <stdlib.h>

static FILE *log_output = NULL;
static LogLevel log_threshold = LOG_LEVEL_DBG; // 默认允许所有级别

// 初始化日志输出流
void logger_init(FILE *output) {
    log_output = output ? output : stderr;
}

// 获取日志级别字符串和颜色
static const char *get_level_info(LogLevel level, const char **color) {
    switch (level) {
        case LOG_LEVEL_ERR:  *color = COLOR_RED;    return "ERROR";
        case LOG_LEVEL_WARN: *color = COLOR_YELLOW; return "WARN";
        case LOG_LEVEL_INFO: *color = COLOR_GREEN;  return "INFO";
        case LOG_LEVEL_DBG:  *color = COLOR_BLUE;   return "DEBUG";
        default:             *color = COLOR_RESET;  return "UNKNOWN";
    }
}

// 核心日志实现
void logger_log(LogLevel level, const char *file, int line, const char *fmt, ...) {
    if (!log_output || level > log_threshold) return;

    // 时间戳
    time_t now = time(NULL);
    char timestamp[20];
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));

    // 日志级别信息
    const char *color = NULL;
    const char *level_str = get_level_info(level, &color);

    // 输出前缀
    fprintf(log_output, "%s[%s]%s %s:%d | ", 
            color, level_str, COLOR_RESET, 
            file, line);

    // 输出用户消息
    va_list args;
    va_start(args, fmt);
    vfprintf(log_output, fmt, args);
    va_end(args);

    // 确保换行
    fputc('\n', log_output);
    fflush(log_output); // 立即刷新缓冲区
}
```

```c
#include "logger.h"

int main() {
    // 初始化日志（输出到stderr）
    logger_init(stderr);

    LOG_ERR("Failed to open file: %s", "test.txt");  // 红色
    LOG_WARN("Connection timeout");                  // 黄色
    LOG_INFO("Server started on port %d", 8080);     // 绿色
    LOG_DBG("Debug value: %d", 42);                  // 蓝色

    return 0;
}
```

上面这个示例中，可以通过设置`LogLevel log_threshold`的值重新编译，这样就能够在程序中显示不同级别的打印。


## 添加主模块和子模块

在实际的工程中，可能包含几个主子模块，就需要对上面的函数进行改进，添加主子模块控制。

```c
// 新增模块标识定义（按位划分）
#define LOG_MODULE_MAJOR_SHIFT   16
#define LOG_MODULE_MINOR_MASK    0xFFFF

// 主模块定义（高16位）
typedef enum {
    MAJOR_NETWORK    = (0x01 << LOG_MODULE_MAJOR_SHIFT),  // 0x00010000
    MAJOR_DATABASE   = (0x02 << LOG_MODULE_MAJOR_SHIFT),  // 0x00020000
    MAJOR_SYSTEM     = (0x03 << LOG_MODULE_MAJOR_SHIFT)   // 0x00030000
} LogMajorModule;

// 子模块定义（低16位）
typedef enum {
    // 网络子模块
    MINOR_NET_UPLOAD     = 0x0001,  // 上传模块
    MINOR_NET_DOWNLOAD   = 0x0002,  // 下载模块
    
    // 数据库子模块
    MINOR_DB_QUERY       = 0x0001,  // 查询模块
    MINOR_DB_TRANSACTION = 0x0002   // 事务模块
} LogMinorModule;

// 组合主+子模块的完整ID
#define LOG_MODULE(major, minor) ((major) | (minor))

// 修改日志函数声明
void logger_log_ex(LogLevel level, uint32_t module, 
                   const char *file, int line, const char *fmt, ...);

// 新增模块控制API
void logger_enable_module(uint32_t module);
void logger_disable_module(uint32_t module);

// 快捷宏（带模块参数）
#define LOG_MOD(level, module, ...) \
    logger_log_ex(level, module, __FILE__, __LINE__, ##__VA_ARGS__)

// 示例：网络上传模块专用宏
#define NET_UPLOAD_LOG(level, ...) \
    LOG_MOD(level, LOG_MODULE(MAJOR_NETWORK, MINOR_NET_UPLOAD), ##__VA_ARGS__)
```

```c
#include <stdint.h>

static uint32_t enabled_modules = 0xFFFFFFFF; // 默认所有模块启用
static LogLevel log_threshold = LOG_LEVEL_DBG; // 默认级别

// 检查模块是否启用
static bool is_module_enabled(uint32_t module) {
    return (enabled_modules & module) == module;
}

// 带模块控制的日志实现
void logger_log_ex(LogLevel level, uint32_t module, 
                  const char *file, int line, const char *fmt, ...) {
    if (level > log_threshold || !is_module_enabled(module)) 
        return;

    // 获取主/子模块名称字符串（需自行实现）
    const char *major_str = get_major_module_name(module >> LOG_MODULE_MAJOR_SHIFT);
    const char *minor_str = get_minor_module_name(module & LOG_MODULE_MINOR_MASK);

    // 输出格式：[LEVEL][MAJOR/MINOR] file:line | message
    fprintf(log_output, "[%s][%s/%s] %s:%d | ",
            level_str, major_str, minor_str, file, line);

    va_list args;
    va_start(args, fmt);
    vfprintf(log_output, fmt, args);
    va_end(args);
    
    fputc('\n', log_output);
}

// 模块控制函数
void logger_enable_module(uint32_t module) {
    enabled_modules |= module;
}

void logger_disable_module(uint32_t module) {
    enabled_modules &= ~module;
}

// 示例模块名称查询函数
static const char* get_major_module_name(uint32_t major) {
    switch (major) {
        case 0x01: return "NET";
        case 0x02: return "DB";
        default:   return "SYS";
    }
}

```

在这个改进版本中，除了`LogLevel log_threshold`打印级别的设置，还添加了主子模块控制。

默认所有模块均启用，即

`enabled_modules = 0xFFFFFFFF;`

结合模块控制函数`logger_enable_module`，即可控制特定模块的开启和关闭。

以网络模块为例
- 仅开启上传模块，应设置
```c
enabled_modules = 0; // 先关闭所有
logger_enable_module(LOG_MODULE(MAJOR_NETWORK, MINOR_NET_UPLOAD));
```
- 仅开启下载模块，应设置
```c
enabled_modules = 0;
logger_enable_module(LOG_MODULE(MAJOR_NETWORK, MINOR_NET_DOWNLOAD));
```
- 关闭所有模块
```c
enabled_modules = 0;
```







结合每个

打印宏里面需要包括打印等级、主模块、子模块等信息

``` c

#define UPLOAD_DBG(...) PRINT_DEBUG(LEVEL_DBG ,PMODULE_TRAFFIC,PMODULE_TRAFFIC_UPLOAD,__VA_ARGS__); 
```

## 主模块与子模块


``` c
//模块主ID
typedef enum{
    PMODULE_TRAFFIC             = 0x0100,  /* 接收处理业务，数据接收，处理，上传业务 */
    PMODULE_DATA_MANAGE         = 0X0200,  /* 数据管理   ，数据库，图片处理业务 */
    PMODULE_SYSTEM				= 0x1100,  /* 系统功能，启动，DSP,  参数，看门狗，升级等 */
    PMODULE_NET					= 0x1300,  /* 网络相关，SDK,  NET,HTTPC, SADP,HTTP,FTP,RTSP, RTSPC.. */
    PMODULE_WEB					= 0x1400,  /* WEB相关，web配置 */
    PMODULE_PERIPHERAL			= 0x1500,  /* 外设相关，串口，音柱,GPS,面板.. */
    PMODULE_STORAGE				= 0x2200,  /* 存储相关 */
}ENUM_MODULE_MAJOR_NO;
```

