
# 嵌入式设备死机经验排查分享

在嵌入式开发中，常常会遇到各种各样的卡死现象。这类问题往往非常让人头疼，因为排查起来非常困难。但是也是有一定的思路和头绪的。

下面就主要总结一下常见的排查思路。



## 1、内存泄漏

这是最常见的导致系统卡死的现象的原因。

C 语言不像其他更高级的语言，没有内存管理机制，需要程序员手动的管理内存。因此容易出现内存泄漏现象。

### 1.1、内存泄漏产生原因


在写代码的时候，以下现象可能会导致内存泄漏：

1. `malloc()`申请的内存没有调用`free()`释放，导致内存泄漏
    ```c
    //直接泄漏
    void func() 
    {
        int *ptr = malloc(sizeof(int)*10);  // 分配后完全没有释放
    }

    //间接泄漏
    void func() 
    {
        int **ptr = malloc(sizeof(int*)*10);
        for(int i=0; i<10; i++) {
            ptr[i] = malloc(sizeof(int)*10);  // 二级指针分配
        }
        free(ptr);  // 只释放了第一级，每个ptr[i]都泄漏了
    }

    //重复释放
    int *ptr = malloc(sizeof(int));
    free(ptr);
    free(ptr);  
    ```
2. 野指针
    ```c
    //未初始化内存访问
    int *ptr;
    *ptr = 10;

    // 内存释放后继续使用指针
    int *ptr = malloc(sizeof(int)*10);
    free(ptr);    
    *ptr = 10;    // 错误：使用已释放内存（不确定行为）

    //函数返回局部变量的地址
    int* func() {
        int num = 10;
        return &num;
    }
    int *ptr = func();
    printf("value is %d\n", *ptr);

    //多个指针指向同一块内存，其中一个释放后其他指针变成野指针
    int *ptr1 = (int *)malloc(sizeof(int));
    if (ptr1 == NULL) {
        printf("内存分配失败！\n");
        return 1;
    }

    int *ptr2 = ptr1;
    int *ptr3 = ptr1;
    *ptr1 = 10;
    free(ptr1);
    printf("释放内存后 ptr2 指向的值: %d\n", *ptr2);
    printf("释放内存后 ptr2 指向的值: %d\n", *ptr2);
    ```
3. 越界: 数组越界、`memcpy()`越界，字符串函数越界
    ```c
    //数组访问越界
    int a[16] = {0};
    a[16] = 1;

    //memcpy越界
    char src[10] = "hello";
    char dest[5];
    memcpy(dest, src, 10);  

    //sprintf越界
    char buffer[10];
    sprintf(buffer, "This is a very long string");

    //strcpy越界
    char dest[10];
    strcpy(dest, "This is a very long string");
    ```

### 1.2、内存泄漏的现象

当发生内存泄漏时，可能会出现以下几种的现象：

|现象|说明|举例|
|-|-|-|
|系统运行变慢，卡顿|系统可用内存逐渐减少，内存不够，程序在运行的过程中，频繁进行内存交换、分配等操作，系统响应时间变长。||
|部分功能异常|某些依赖于大量内存的功能模块可能由于内存泄漏无法工作。比如一些图像识别，数据存储等||
|系统频繁崩溃或者重启|系统可用内存几乎耗尽时，程序可能会因为无法分配到所需的内存而崩溃重启。|<li>进程内存泄露，如果访问到了非法内存，比如内核的内存地址，此时内核就会抛出一个`undefined signal 11`段错误异常，此时系统就会立刻进行重启<li>进程内存泄露，但并未访问到非法内存，只是不停占用系统的空闲堆内存而没有及时释放，当超过内核设定的系统最小空闲内存阈值时，触发`OOM`，内核默认杀死占用内存最大的进程，设备进行重启。|
|错误日志增多|系统的错误日志中可能会出现与内存相关的错误信息，如内存分配失败、访问越界等|设备`SSH`或者串口刷新一些内存异常的打印，这些打印在系统正常工作时不会出现|


### 1.3、内存泄漏的排查解决思路

内存泄漏只能从上面描述的现象中进行发现。其中系统崩溃是最容易直观发现的。会伴随以下几种现象。

1. 设备无法`ping`通。
2. `SSH`连接突然断开。
3. 设备的`web`页面无法访问，访问设备的`web`页面的本质就是设备软件的`appweb`处理前端浏览器客户端的访问`web`的请求。当设备死机时，自然无法处理该请求，即无法访问`web`。

当有这几种现象时，就很有可能是内存泄露导致的设备死机。

排查思路有以下几种

|工具|适用场景|
|-|-|
|有串口线|<li>设备接串口线，需要保证设备的串口波特率和`PC`端的波特率一致，否则会串口会出现乱码<li>通过一些终端软件例如`XShell`等监测设备的串口日志。<ul><li>当内存泄露引发`undefined signal 11`段错误时，可以通过串口日志获取挂掉的进程`PID`，`PC`和`LR`地址，结合`addr2line`工具定位到死机的是哪一个进程，位于代码中的哪一行等信息。<li>当内存泄漏引发`out of memery(OOM)`时，|
|无串口线，仅能在设备在线时登录`SSH`||
|||




### 1.4、内存泄漏的预防