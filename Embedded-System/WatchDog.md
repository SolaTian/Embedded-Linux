# WatchDog

嵌入式设备一般都是有一个主进程，若干个子进程一起协同工作的，当我们的设备主进程在运行过程中由于一些因素挂掉时，整个系统都会崩溃，设备挂掉开始重启，如果这个因素必现，那么设备就会出现反复重启的情况。什么都无法操作。“设备就变砖了”，这种情况非常让人头大，只能带着串口线到设备旁边进行串口升级……

既然嵌入式系统是一个 Linux 系统，是一台“电脑”，那么为什么一个进程挂掉之后，这个“电脑”就起不来了呢？

嵌入式系统由于资源受限，当主进程崩溃之后，系统重启的原因可能为：

1. 主进程负责初始化硬件，加载必要的驱动，缺少主进程，系统将无法正常运行
2. 嵌入式系统不像正真的电脑，缺乏复杂的错误处理恢复机制
3. 主进程往往负责关系系统资源，如内存、I/O 设备等。主进程崩溃可能导致资源无法正确释放或管理，其他进程可能无法继续运行，迫使系统重启。
4. 看门狗机制：嵌入式系统中常用看门狗定时器来监控系统状态。如果主进程因故障未能在指定时间内重置看门狗，系统将自动重启以避免死机。

前面几点原因可能与嵌入式系统的特性、内核机制有关。看门狗机制可以在主进程应用软件中或者硬件中设置，来主要研究一下。

## Watchdog 的分类

|特性|软件看门狗 Software Watchdog |硬件看门狗 Hardware Watchdog|
|-|-|-|
|实现方式|软件实现，依赖系统进程，一般是主进程|硬件电路实现，独立于系统软件。|
|监控范围|监控特定进程或系统状态。|监控整个系统运行状态。|
|触发机制|软件检测异常条件，触发恢复措施。|硬件检测超时或异常，触发硬件重置。|
|可靠性|可靠性依赖于软件，可能受软件崩溃影响。|硬件独立运行，可靠性更高。|
|灵活性|高（可自定义策略，如动态超时、分级恢复）|低（超时时间固定，功能单一）|
|资源需求|无需额外硬件，完全软件实现，仅消耗 CPU 和内存资源。|需要额外硬件（定时器模块），增加系统复杂性和成本。|
|典型操作|重置计数器、检查任务心跳|写寄存器喂狗|
|应用场景|适用于资源受限的嵌入式系统。|适用于高可靠性要求的嵌入式系统。|


## 软狗 Software Watchdog

> 软狗（Software Watchdog），是一种通过软件实现的监控机制。监控系统的运行状态，确保系统或特定进程在预期的时间内正常响应。如果系统或进程由于某种原因（如崩溃、死锁或无限循环）未能及时响应，软狗会触发相应的恢复措施，例如重启系统或启动错误处理程序。

### 单任务系统中的软狗

软狗的工作原理：
1. 主进程在初始化时，会初始化一个软件看门狗，比如一个定时器，初始化时设置一个超时时间（例如3秒），并启动定时器倒计时。
   
        // 伪代码示例：初始化看门狗
        void watchdog_init() {
            watchdog_counter = 3000;  // 初始化超时时间为3秒（单位：毫秒）
            is_watchdog_active = true;
        }

2. 系统运行过程中，关键任务（如数据采集、通信处理）需定期更新状态标志或计数器（"喂狗"）。看门狗通过检查这些标志来判断任务是否正常执行。


        // 关键任务示例：每1秒更新一次状态
        void critical_task() {
        static uint32_t last_update = 0;
        if (current_time - last_update >= 1000) {
            perform_task_operations();     // 执行任务操作
            last_update = current_time;   // 更新状态时间戳
            task_healthy = true;          // 标记任务为健康状态
            }
        }
        // 喂狗操作：重置看门狗定时器
        void feed_dog() {
            reset_timer(TIMER_WDT);  // 重置定时器计数
        }

        // 主循环中定期喂狗
        while (1) {
            run_tasks();          // 执行所有任务，调用critical_task()
            if (check_task_health()) { // 检查任务状态是否正常
            feed_dog();       // 任务正常则喂狗
            }
            // 若任务异常，喂狗操作被跳过，定时器溢出触发复位
        }
3. 当定时器未被及时置位（未及时喂狗），触发预定义的恢复操作
   1. 系统复位：强制重启，恢复初始状态
   2. 日志记录：将故障信息保存到非易失存储器（如 Flash ）
   3. 降级运行：关闭非核心功能，进入安全模式

            // 伪代码：超时检测 
            void check_watchdog() {
                if (watchdog_counter <= 0) {
                    log_error("看门狗超时！系统复位中...");
                    system_reset();  // 触发复位
                }
            }


### 多任务系统中的软狗

注意看上面这种模式，若有多个任务，在主循环中，需要等到所有任务都完成，才允许喂狗。假设 A 任务每 1s 执行一次，B 任务每 2s 执行一次，则需要 2s 才喂狗。

这种在主循环中统一喂狗，适用于一些简单系统，且会遗漏任务级监控。

在多任务系统中，可以每个任务维护自己的一个子看门狗，不同优先级的任务分配独立的看门狗。

    // 任务A的看门狗
    void task_a() {
        static int task_a_counter = 1000;
        run_task_a();
        task_a_counter = 1000;  // 任务A完成后重置自身计数器
    }

    // 任务B的看门狗
    void task_b() {
        static int task_b_counter = 100;
        run_task_b();
        task_b_counter = 100;  // 任务B完成后重置自身计数器
    }

    // 全局看门狗检查所有子计数器
    void global_watchdog() {
        if (task_a_counter <= 0 || task_b_counter <= 0) {
            trigger_recovery();
        }
    }   

这样可以精准定位故障任务。


### 心跳机制实现软狗

虽然多任务的子看门狗可以精确的定位到具体某个任务的故障。但是不管是单一任务的单一定时器，还是多任务的多定时器。发生故障时都会产生中断。频繁的定时器中断可能会影响实时任务的性能。


在分布式的系统中，可能有多个独立的任务或模块，每个模块需要独立报告状态。除了使用子看门狗机制，还可以使用消息队列或者共享内存来实现看门狗。

消息队列提供了一种集中式的方式收集这些状态，方便看门狗统一处理。消息队列允许动态添加或移除被监控的任务，而无需重新配置定时器，可以节约定时器资源。这对于需要动态加载插件或模块的系统尤其有用。

1. 在主进程中，初始化一个全局的消息队列
   
        //伪代码，初始化全局消息队列
        void watchdogInit(){
            QueueHandle_t health_queue = xQueueCreate(10, sizeof(TaskHealthMsg));
        }    

2. 主进程中，正常运行各个任务

        int main(){
            watchdogInit();
            task_A();
            task_B();
            ...
            watchdog_task();
        }

3. 主进程中，另起一个看门狗监控任务，通过任务自身`task_A()`函数向消息队列发送心跳（“喂狗”，喂狗时包含任务 ID 等信息）

        void watchdog_task(void *params) {
            TaskHealthMsg msg;
            uint32_t last_heartbeat[MAX_TASKS] = {0};
    
            while (1) {
                // 接收心跳消息（阻塞或非阻塞）
                if (xQueueReceive(health_queue, &msg, pdMS_TO_TICKS(500)) == pdTRUE) {
                    last_heartbeat[msg.task_id] = get_current_timestamp();
                }
        
                // 检查所有任务是否超时
                for (int i = 0; i < MAX_TASKS; i++) {
                    if (get_current_timestamp() - last_heartbeat[i] > TASK_TIMEOUT_MS) {
                        handle_task_failure(i); // 触发恢复操作
                    }
                }
            }
    }
4. 看门狗任务持续监听队列，记录各任务最后一次心跳时间,若某任务在预设时间内未发送心跳，判定为故障。
5. 故障处理
    1. 自动恢复：重启故障任务或整个系统。
    2. 日志记录：将故障信息写入非易失存储器（如Flash）。
    3. 告警通知：通过LED、蜂鸣器或网络通知外部系统。



### 心跳机制与子看门狗的比较

心跳机制和前面说的子看门狗都可以监控多任务系统，那么它们有哪些区别呢？

|特性|多任务的子看门狗|共享内存/消息队列的看门狗|
|-|-|-|
|监控粒度|	每个任务独立监控，细粒度（定位到具体任务）|	集中监控，通过消息/共享数据标识任务，需额外解析|
|实现复杂度|	每个任务需独立维护计数器，逻辑分散	|中央看门狗统一管理，需处理并发访问（如互斥锁）|
|资源占用|	每个任务占用独立计数器（内存消耗较高）|	共享数据结构或队列（通信开销为主）|
|实时性|	任务自主管理，响应快（无通信延迟）|	依赖消息传递或共享数据更新，可能存在延迟|
|扩展性|	新增任务需单独配置监控，扩展性差	|新任务仅需注册心跳，扩展灵活
|故障隔离能力|	可直接定位故障任务，针对性恢复（如重启单个任务）|	需解析消息定位故障，恢复策略可能更复杂|
|典型应用场景|	任务独立性高、需快速恢复特定功能的系统（如工业控制器）|	多任务协作、动态扩展的系统（如物联网网关、分布式节点）|

### 心跳机制的优势

心跳机制有以下优势

|优势|说明|
|-|-|
|细粒度监控|可独立监控每个任务的健康状态，而非仅检测整体系统活性。|
|动态扩展性|新任务只需注册并发送心跳即可加入监控，无需修改看门狗核心逻辑。|
|减少硬件依赖|不占用硬件定时器资源，依赖软件计时（如系统时钟节拍）|
|避免中断冲突|无需定时器中断，减少上下文切换和资源竞争问题。|

### 软件看门狗复位举例

当一个嵌入式系统存在多个任务时，比如循环检测硬盘状态，重要次进程，当硬盘状态异常，或者由于次进程不能定时给主进程发送心跳。这时候就会由软件看门狗监测到并触发系统复位操作。

## 硬狗 Hardware Watchdog

软狗介绍的差不多，下面开始聊硬狗。

> 硬件看门狗是一种独立于 CPU 的硬件电路，通常集成在微控制器（MCU）或专用芯片中。其核心是一个倒计时定时器，需在超时前被“喂狗”（重置），否则触发系统复位。


### 硬件看门狗的工作原理

硬件看门狗的工作原理：

- 初始化：配置超时时间（如1秒），启动看门狗。
- 喂狗（Reset）：CPU 定期通过写寄存器或特定操作重置定时器电路。
- 超时处理：若未及时喂狗，看门狗触发系统复位信号。

硬件看门狗并不是完全不需要程序进行参与的。喂狗操作必须要由软件来实现。硬件看门狗的功能是由硬件和软件共同实现的。

1. 硬件部分包括独立的时钟源、计数器、复位电路，即硬件提供定时器和复位功能。
2. 软件部分则是通过程序定期访问看门狗的寄存器，这个动作需要由程序代码完成，即软件负责定期喂狗。

### 硬件看门狗的特点

|特点|说明|
|-|-|
|独立性|由独立时钟源驱动，不依赖CPU或软件。|
|高可靠性|即使 CPU 死锁、程序跑飞，仍能强制复位|
|不可编程性|超时时间固定（某些芯片支持有限配置）|


### 硬件看门狗复位举例

#### 主进程内存泄露或者 OOM 导致系统反复重启

像上面提到的，当主进程由于内存泄露或者 OOM 的原因被内核杀死之后，由于主进程无法执行写寄存器的喂狗操作，导致硬件看门狗定时器无法及时清零，系统复位。


#### 判断系统由于哪种看门狗复位

调试阶段禁用软件看门狗，通过宏控制

- 若系统仍然会出现重启，则系统复位由硬件看门狗执行
- 若系统不再重启，则系统复位由软件看门狗执行