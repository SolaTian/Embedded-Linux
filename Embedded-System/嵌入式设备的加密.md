# 嵌入式设备的加密

在一些商业应用的嵌入式设备中，经常会存在硬件平台一致，但是软件功能不同，语言不同的情况。在本地调试时，往往设备有限，需要跨设备升级和验证功能。

## 必要前提

> 嵌入式设备在启动时，运行到主进程时，会从系统的某个目录下读取当前设备加密的配置文件(比如`/dev/params`) ，软件会去读取当前这个设备的该文件，将得到的设备配置存放在一个全局的结构体变量中(如`bootparams`，其中包括语言，型号，序列号等重要信息)，后续关于系统的所有参数都是基于这个全局变量。

> 嵌入式设备在主进程初始化的时候会获取设备能力集，这个能力集是根据`bootparams`中读取到的设备型号将设备的一些基本能力赋值到一个全局变量中，这些能力与系统支持的一些功能、逻辑是息息相关的。

> 一般的嵌入式固件除了包括主进程 app 之外，还会包括一些文件、其他进程、动态库等。将它们打包签名之后生成某种格式的文件。该文件头部往往会包括当前该固件的一些重要信息，比如语言、设备型号、版本号等。在 Web 设备升级时，升级模块都会将这些头部信息解析出来与当前系统`bootparams`的程序语言、设备型号、版本号进行比对。若校验不通过，则会 Web 上提示失败。



A 设备根据具体的使用场景分成不同语言和方案
- 中文三种不同方案设备：A-CN，A-mod1-CN，A-mod2-CN
- 英文三种不同方案设备：A-EN，A-mod1-EN，A-mod2-EN

**所有的方案设备的硬件都是相同的，同方案不同语言的设备能力集相同，同语言不同方案的设备能力集不同。**

固件需要经过编译和打包

    #编译命令
    make A [-i modx]
    #打包命令
    pack A [-i modx] [-l language]

例如

    #编译打包A-mod1的中文固件
    make A -i mod1
    pack A -i mod1 =l CN

    #编译打包A的英文固件
    make A
    pack A -l EN




## 方案(设备型号)不同

假设在本地开发调试时，仅有设备 A-CN，但是我却需要开发设备 A-mod1-CN 的程序并验证功能。

由上面的知识可以知道，正常的流程应该是

    make A -i mod1
    pack A -i mod1 -l CN 

显然在 Web 上升级是会校验失败的。因为固件的头部信息与设备 A-CN 中运行的程序校验时会失败。

可以通过以下的办法来尝试升级：

1. `make A -i mod1 & pack A -l CN`，将固件型号头部信息的型号改成 A-CN，直接从 A-CN 设备的 Web 进行升级。

    流程分析：
    1. `make A -i mod1`使用了 A-mod1-CN 的逻辑功能
    2. `pack A -l CN`将固件包的头部信息设备型号写成 A-CN
    3. Web 升级校验系统当前型号和固件头部型号通过，升级成功。
    4. 如果被升级的 A-mod1-CN 这个固件的主进程在初始化时，能够获取到当前这个设备的能力集，即软件程序中包含 A-CN 这个型号，能够获取到设备的能力集，设备可以正常启动。
    5. 如果不能够获取到当前这个设备的能力集，则可能由于软件的缘故，系统无法正常启动，反复重启。
    6. 如果设备能够正常启动，后续只需要在 Web 升级即可
    7. 如果设备启动脚本支持挂载主进程 app 调试，则可以断电进行调试，无需再升级。
  
2. `make A -i mod1 -l CN & pack A -i mod1 -l CN`，直接编译打包 A-mod1-CN 设备的固件，然后通过串口升级，串口会跳过同语言的不同型号的设备校验。

    流程分析：
    1. `make A -i mod1`使用了 A-mod1 的逻辑功能
    2. `pack A -i mod1 -l CN`将固件包的头部信息设备型号写成 A-mod1-CN
    3. 串口升级跳过型号的校验，升级成功
    4. 如果被升级的 A-mod1-CN 这个固件的主进程在初始化时，能够获取到当前这个设备的能力集，即软件程序中包含 A-CN 这个型号，能够获取到设备的能力集，设备可以正常启动
    5. 如果不能够获取到当前这个设备的能力集，则可能由于软件的缘故，系统无法正常启动，反复重启。
    6. 如果设备能够正常启动，后续只需要在串口升级即可
    7. 如果设备启动脚本支持挂载主进程 app 调试，则可以断电进行调试，无需再升级。

3. `make A -i mod1 -l CN & pack A -i mod1 -l CN`，通过加密狗将设备 A-CN 加密成 A-mod1-CN，之后的第一次升级使用串口进行升级刷掉设备中原有的 A-CN 程序，后续升级 A-mod1 固件就可以使用 Web 进行升级。

   流程分析：
    1. `make A -i mod1`使用了 A-mod1 的逻辑功能
    2. `pack A -i mod1 -l CN`将固件包的头部信息设备型号写成 A-mod1-CN
    3. 通过加密狗将设备的`/dev/params`文件进行加密，使得设备型号变成 A-mod1-CN
    4. 当前 A-CN 中主程序为 A-CN，通过串口将固件刷到加密后的设备中就可以正常启动。
    5. 设备正常启动，如果设备启动脚本支持挂载主进程 app 调试，则可以断电进行调试，无需再升级。

## 语言不同

假设在本地开发调试时，仅有设备 A-CN ，但是却需要开发设备 A-EN 的程序并验证功能

正常的编译打包命令应该如下

    make A -l EN
    pack A -l EN

显然在 Web 上升级是会校验失败的。

Web 升级和串口升级都会失败，Web 升级失败因为程序会去校验升级的固件头的语言类型，不匹配则无法升级成功。串口为什么会升级失败呢？串口不是跳过软件校验的吗？

设备通过串口升级可能会绕过某些检验，但仍然可能会执行一些基本的校验，比如是语言这种。所以串口也无法刷进去。

可以通过下面几种方法尝试升级：

1. `make A & pack A -l CN`，在程序中，将程序的语言写死成为英文，直接通过 Web 升级或者通过串口升级到中文设备中。后续升级就可以从 Web 进行升级了，但是需要注意的是，后续应该 make A & pack A -l EN，再从 Web 升级，因为设备的语言已经被写成英文了。所以固件也需要打包成为英文的，才能在 Web 升级时通过程序的校验。

    流程分析：
    1. 在程序的获取`bootparams`时，手动修正获取到的设备语言，强制写死成英文。
    2. `make A`同时支持英文和中文的功能
    3. `pack A -l CN`将固件包的头部信息语言写成 A-CN
    4. Web 升级校验系统当前语言和固件头部语言通过，升级成功。
    5. 由于固件中肯定包含当前设备 A-CN 的能力集，所以可以正常启动。
    6. 设备正常启动后，该固件的主进程在初始化获取`bootparams`时，语言被修正为英文，设备按照英文显示
    7. 后续升级时由于设备当前的`bootparams`为英文，因此后续只需要`make A & pack A -l EN`即可正常从 Web 升级（注意语言还是要强制写死成英文，否则设备起来之后获取的`bootparams`还是中文）。
    8. 串口升级也是同样的步骤，第一次使用中文固件升级，后续从 Web 进行升级。
    9. 如果设备启动脚本支持挂载主进程 app 调试，则可以断电进行调试，无需再升级。
   
2. `make A & pack A -l EN`，通过加密狗将设备进行加密，将其语言加密成为英文，直接从 Web 进行升级。
    流程分析：
    1. `make A `同时支持英文和中文的功能
    2. `pack A -l CN`将固件包的头部信息语言写成 A-EN
    3. 通过加密狗将设备的`/dev/params`文件进行加密，使得设备语言变成 A-EN
    4. 当前的设备就被加密成了 A-EN，界面直接显示英文。
    5. 设备直接从 Web 进行升级，如果设备启动脚本支持挂载主进程 app 调试，则可以断电进行调试，无需再升级。

## 加密狗是什么

> 加密狗是一个硬件设备，用于对设备的核心功能、软件授权、配置参数（如设备型号、语言设置等）进行加密保护。



### 加密狗的组成


加密狗由硬件部分和软件部分组成，下面分别来介绍各个部分的组成

|硬件组成|说明|
|-|-|
|安全芯片|核心组件，主要用于<li>密钥存储：存储私钥、证书、设备唯一标识<li>加密运算：硬件加速执行加密算法|
|接口|<li>USB 加密狗<li>NFC/RFID 加密狗（门禁卡形态）等|
|存储单元|<li>OTP(一次性可编程存储器)：用于存储根密钥<li>EEPROM/Flash：可擦写存储，保存配置数据或动态密钥<li>安全存储区：受硬件保护的存储区域|
|加密引擎|硬件加速模块 <li>对称加密，如 AES，DES 等<li>非对称加密：RSA 等 <br>随机数生成器，生成真随即数，用于密钥的生成|


|软件组成|说明|
|-|-|
|固件|<li>芯片初始化：启动时配置安全芯片的时钟、接口、加密引擎<li>协议栈: 实现通信协议（如 USB 协议栈）<li>安全逻辑：定义密钥使用策略|
|驱动程序|在主机（如 PC 或 嵌入式系统）中实现硬件与操作系统的通信<li>通用驱动：如 USB HID/CCID 驱动<li>专用驱动: 厂商私有协议驱动|
|上层软件工具|加密狗管理软件<li>密钥管理:生成、导入、绑定密钥到加密狗<br>开发库 <li>标准化加密接口 PKCS#1<li>厂商专有 SDK|

### 加密狗的作用

加密狗的作用类似于一个硬件密钥，只有在插入到或者连接到指定设备的时候，才能解密或者启用设备的某些功能或者配置信息。

|作用|说明|
|-|-|
|软件授权和版权保护|<li>加密狗通过硬件设备提供唯一的标识符，确保软件只能在授权的设备上运行，防止软件被非法复制或盗版<li>软件通常需要加密狗中的密钥或标识符进行激活，未插入加密狗时软件无法运行或仅能运行有限的功能|
|控制设备功能|<li>加密狗可以控制软件功能的启用或禁用。例如，只有在插入特定的加密狗时，高级功能或模块才能被启用<li>加密狗可以绑定设备的型号信息，确保软件在特定设备上运行，防止跨设备使用|
|加密与数据保护|<li>加密狗可以对设备中的敏感数据、软件代码、配置信息等进行加密存储，防止数据被篡改或窃取<li>加密狗内部存储加密密钥，用于解密和验证设备中的关键信息（如设备型号、语言、内核等）。|

### 加密狗的分类

|分类|场景|
|-|-|
|USB 加密狗|即插即用, 适用 PC 或者嵌入式主机|
|嵌入式安全芯片|直接集成到设备 PCB, 无需外部接口|
|智能卡|适用于高安全场景, 如金融, 政府|

## USB 加密狗加密的流程

### 准备

- 加密狗(U盘)
- 加密服务器(PC)
- tftp服务器软件: 通过 tftp 向嵌入式设备传输加密后的固件
- MicroDog 驱动软件:
- 加密软件(ProductInfoConfig.exe): 与加密狗交互,完成固件加密和密钥管理
- 嵌入式设备: 要求支持 U-Boot, 且已集成加密/解密功能, 网络接口已经配置, 可以与 tftp 服务器通信

一般来说，加密狗、加密狗驱动、加密软件三者是配套的。

### 加密过程原理


|步骤|说明|注意点|
|-|-|-|
|安装加密狗驱动|安装 MicroDog 加密狗驱动。主要目的就是为了让电脑能够识别加密狗硬件。|<li>应该使用厂商提供的官方驱动（避免产生兼容性问题）<li>安装后可以通过设备管理器查看加密狗的识别状态。|
|插入 USB 加密狗|建立物理连接||
|运行加密软件|加密软件会通过驱动检测加密狗是否存在，若加密狗和当前加密软件不匹配, 可能会出现报错提示。 并且进入加密软件之后页面参数全部置灰不可编辑。|加密狗软件需要和加密狗匹配|
|加密狗软件读取参数|加密狗软件通过加密狗内含的 API 接口`ReadData()`读取加密狗内部的加密参数，并将这些参数输出显示在软件上||
|修改并绑定加密狗参数|在软件上配置新的加密参数，如设备型号、语言等。修改完成后点击保存参数，参数经加密狗加密之后保存||
|电脑端启用 TFTP 服务器|为嵌入式设备提供加密后的配置文件或者固件|确保网络正常，且 UDP 69端口是通的|
|Uboot 中设置网络参数|在嵌入式设备的 Uboot 中，设置网络参数<br>`setenv ipaddr`<br>`setenv serverip`<br>`saveenv` ||
|在 Uboot 中运行 `run sec`命令|`run sec`将加密好的固件传输到嵌入式设备中，并解密验证，验证通过后显示加密成功|<li>需要注意 Uboot 需要集成机密狗驱动。<li>`sec`是 Uboot 中预定义的脚本，可能包含以下操作<br>`setenv sec 'tftp 0x80000000 encrypted_firmware.bin; verify_signature 0x80000000; bootm 0x80000000'` <br>包括以下步骤<li>从 TFTP 服务器下载固件到内存地址 0x80000000。<li>调用 verify_signature 验证签名。<li>验证通过后启动固件（公钥已经烧录在嵌入式设备的安全存储区域）。|


整个过程中加密狗作为一个签名和加密工具，加密后的固件可以被设备中的公钥进行验证。假设一些第三方对固件进行非法加密，公钥验证不通过，在嵌入式设备中验证失败是会直接拒绝加密的。











