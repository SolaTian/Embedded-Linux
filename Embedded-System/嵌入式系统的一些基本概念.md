# 嵌入式系统的一些基本概念

## 并行通信与串行通信

|通信分类|说明|距离|
|-|-|-|
|并行通信|同时使用多条数据线，一次传输多个比特（通常是8位、16位、32位）|<li>数据总线/地址总线（`MCU`内部）: `MCU`访问外部`SRAM`/`Flash` 等等|
|串行通信|使用1~2根数据线，数据一位一位顺序传输|<li> `UART`:串口通信、调试信息打印 <li> `SPI`: 传感器、Flash、显示屏等高速通信 <li> `I²C`: 多设备总线通信，如 `EEPROM`、`RTC`<li> `USB、CAN、Ethernet`: 外设连接、高速通信、网络|


### 为什么需要串行通信

主要有以下几点原因：

1. 嵌入式芯片引脚有限，比如 `MCU` 只有几十根 `IO`，并行通信会占用大量`IO`口（如并行`LCD`通常要20+线），而串行 `SPI/I²C` 只需几根。

2. 并行线切换频繁，电磁干扰大；串行通信信号变化少，更安静、能耗低。


### `UART`

> `UART`是一种异步通信的硬件协议，硬件模块，在网络模型中属于数据链路层。负责将数据封装成帧并通过串口发送。

`UART` 的特点：
1. 使用 `起始位 + 数据位 + 校验位 + 停止位` 的结构
2. 不需要时钟线

### 串口

> 串口是一种串行通信的接口，通常使用 `UART`协议发送和接收数据。

在不同的平台上，设备管理器显示不同：

1. `Windows`: `COM1`、`COM2`...
2. `Linux/MacOS`: `/dev/ttyS0`、`/devttyUSB0`...

串口可以看做是一个 `UART模块+电器接口`

串口可以通过不同的电气标准传输。其中就包括`RS232`与`RS485`

||||
|-|-|-|
||||

通过串口通信的双方，需要保持波特率（每秒传输的`bit` 数）的一致，否则数据的接收就会出现乱码。




## 进程和线程的关系

> 进程和线程的关系。进程是操作系统分配资源的基本单位，而线程是进程内的执行单元。一个进程可以有多个线程，这些线程共享进程的资源，比如内存空间和文件句柄。

## 线程卡死是否会一定导致进程卡死

答案是不一定的。

1. 如果线程卡死是因为它在等待某个永远不会发生的资源或事件，比如死锁或者无限等待`I/O`，而主线程或其他关键线程也被阻塞了，那么整个进程可能会卡死。
2. 如果只是其中一个子线程卡死，而主线程还在运行，可能进程还能继续，只是部分功能不可用。


## 进程卡死的主要原因

- 死锁：多个进程或线程互相等待对方释放资源（如锁、文件句柄），形成循环依赖。
- 资源耗尽：内存泄漏：进程持续占用内存不释放，最终触发 OOM（Out of Memory）。
- 文件描述符耗尽：进程打开文件/网络连接后未关闭，导致无法创建新资源。
- 无限循环（死循环）：主线程陷入死循环且无法被中断（如未设置退出条件），导致进程无法响应其他任务。
- 外部依赖故障：进程等待外部资源（如数据库、网络请求）时长时间阻塞，且未设置超时机制。
- 硬件/系统问题：磁盘损坏、CPU 过载、操作系统内核错误等。
- 系统`I/O`过高

## 系统 `I/O`

嵌入式系统 `I/O` 包括 
1. 存储`I/O`: Flash、 SD 卡、硬盘、 eMMC 的读写
2. 网络`I/O`: 以太网、Wi-Fi、蓝牙的数据吞吐
3. 外设`I/O`: UART、SPI、I2C、GPIO等低速总线通信
4. 内存压力: DMA传输、内存与缓存的分配

当系统的`I/O`过高时，可能会出现进程卡死的原因


|系统 IO 过高|说明|举例|
|-|-|-|
|IO 队列饱和|当磁盘、网络等 `IO` 负载过高时，请求会被积压在操作系统的 `IO` 队列中进程发起同步`I/O`操作（如未设置超时的读写）时，可能因等待资源而长时间阻塞。|数据库因磁盘`I/O`过载无法完成数据写入，导致后续操作停滞|
|中断和上下文切换|高I/O负载可能引发大量硬件中断（如`UART`接收数据、`SPI`传输完成），导致`CPU`忙于处理中断服务程序（`ISR`），用户进程无法获得执行时间。|`CPU`使用率看似不高，但实际时间被内核占用，用户进程响应缓慢|
|内存资源耗尽|嵌入式系统内存有限，若`I/O`操作未合理管理缓冲区（如网络数据积压、未释放`DMA`缓存），可能耗尽内存，触发系统崩溃或进程冻结。|嵌入式系统通常无磁盘交换分区，内存不足时直接触发`OOM`（`Out-of-Memory`）错误|
|优先级反转|低优先级进程占用`I/O`资源（如串口），高优先级进程被迫等待，导致关键任务延迟|高优先级数据采集任务因等待低速`I/O`（如`SD`卡存储）而错过截止时间，引发系统复位|

