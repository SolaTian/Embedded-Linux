# 嵌入式系统的进程、线程

## 进程和线程的关系

> 进程和线程的关系。进程是操作系统分配资源的基本单位，而线程是进程内的执行单元。一个进程可以有多个线程，这些线程共享进程的资源，比如内存空间和文件句柄。

## 线程卡死是否会一定导致进程卡死

答案是不一定的。

1. 如果线程卡死是因为它在等待某个永远不会发生的资源或事件，比如死锁或者无限等待`I/O`，而主线程或其他关键线程也被阻塞了，那么整个进程可能会卡死。
2. 如果只是其中一个子线程卡死，而主线程还在运行，可能进程还能继续，只是部分功能不可用。


## 进程卡死的主要原因

- 死锁：多个进程或线程互相等待对方释放资源（如锁、文件句柄），形成循环依赖。
- 资源耗尽：内存泄漏：进程持续占用内存不释放，最终触发 OOM（Out of Memory）。
- 文件描述符耗尽：进程打开文件/网络连接后未关闭，导致无法创建新资源。
- 无限循环（死循环）：主线程陷入死循环且无法被中断（如未设置退出条件），导致进程无法响应其他任务。
- 外部依赖故障：进程等待外部资源（如数据库、网络请求）时长时间阻塞，且未设置超时机制。
- 硬件/系统问题：磁盘损坏、CPU 过载、操作系统内核错误等。
- 系统`I/O`过高

### 死锁

> 死锁是指多个进程（或线程）因争夺资源而陷入相互等待的僵局。

死锁的发生必须要满足4个必要条件，要解决死锁只需要破坏其中任意一个条件

|必要条件|说明|特征|破坏方法|
|-|-|-|-|
|互斥条件|资源具有排他性，一次只能被一个进程使用。<li>打印机、数据库锁等独占资源|资源独占使用|增加资源副本/使用共享资源|
|请求与保持条件|进程已持有至少一个资源，同时请求其他进程持有的资源，且在等待期间不释放已持有资源<li>进程A持有资源X，请求资源Y；<li>进程B持有资源Y，请求资源X。|占用资源的同时请求新资源|一次性申请所有资源|
|不可剥夺条件|进程已获得的资源不能被强制剥夺，只能由持有者主动释放<li>正在写入的文件若被强制剥夺会导致数据损坏|资源不可被强制回收|允许操作系统剥夺资源|
|循环等待条件|存在进程资源的环形等待链：<li>P₁ 持有 R₁ 并请求 R₂，<li>P₂ 持有 R₂ 并请求 R₃，<li>…<li>Pₙ 持有 Rₙ 并请求 R₁。|进程-资源形成等待环|	强制按固定顺序申请资源|



### 系统 `I/O`

嵌入式系统 `I/O` 包括 
1. 存储`I/O`: Flash、 SD 卡、硬盘、 eMMC 的读写
2. 网络`I/O`: 以太网、Wi-Fi、蓝牙的数据吞吐
3. 外设`I/O`: UART、SPI、I2C、GPIO等低速总线通信
4. 内存压力: DMA传输、内存与缓存的分配

当系统的`I/O`过高时，可能会出现进程卡死的原因


|系统 IO 过高|说明|举例|
|-|-|-|
|IO 队列饱和|当磁盘、网络等 `IO` 负载过高时，请求会被积压在操作系统的 `IO` 队列中进程发起同步`I/O`操作（如未设置超时的读写）时，可能因等待资源而长时间阻塞。|数据库因磁盘`I/O`过载无法完成数据写入，导致后续操作停滞|
|中断和上下文切换|高I/O负载可能引发大量硬件中断（如`UART`接收数据、`SPI`传输完成），导致`CPU`忙于处理中断服务程序（`ISR`），用户进程无法获得执行时间。|`CPU`使用率看似不高，但实际时间被内核占用，用户进程响应缓慢|
|内存资源耗尽|嵌入式系统内存有限，若`I/O`操作未合理管理缓冲区（如网络数据积压、未释放`DMA`缓存），可能耗尽内存，触发系统崩溃或进程冻结。|嵌入式系统通常无磁盘交换分区，内存不足时直接触发`OOM`（`Out-of-Memory`）错误|
|优先级反转|低优先级进程占用`I/O`资源（如串口），高优先级进程被迫等待，导致关键任务延迟|高优先级数据采集任务因等待低速`I/O`（如`SD`卡存储）而错过截止时间，引发系统复位|

